<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyrule</title>
  
  <subtitle>Life Is Short</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-26T08:43:46.814Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wanglei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Onsets and Frames Dual-objecive piano transcription</title>
    <link href="http://yoursite.com/2019/06/26/Onsets/"/>
    <id>http://yoursite.com/2019/06/26/Onsets/</id>
    <published>2019-06-26T07:51:12.000Z</published>
    <updated>2019-06-26T08:43:46.814Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-文章出处"><a href="#1-文章出处" class="headerlink" title="1.文章出处"></a>1.文章出处</h4><p>发在2018ISMIR,来自Google Brain团队,<a href="https://arxiv.org/pdf/1710.11153.pdf" target="_blank" rel="noopener">paper链接</a></p><h4 id="2-文章简介"><a href="#2-文章简介" class="headerlink" title="2.文章简介"></a>2.文章简介</h4><blockquote><p>“这篇文章已经把钢琴自动转录未来五年甚至十年的工作都做完了”. 我们用程序Demo转换了一首比较复杂的钢琴曲,听到转录的结果, 于是发出了这样的感叹.</p></blockquote><p>本篇论文主要解决的问题是复音钢琴自动转录,也就是将原始的钢琴演奏音频转换为MIDI表示. </p><p>这篇论文的主要方法使用了一个onset检测器和一个framewise检测器,framewise检测器的预测值收到onset检测器值的限制:<strong>只有onset检测器同意在帧中有onset的存在,framewise检测器才会预测一个新的音符</strong>.作者认为只有同时改善音符的onset和offset才符合人类对音乐的感知.作者还拓展了模型预测velocity值,使得转录的结果听起来更加自然.</p><p>在MAPS数据集的转录结果在Note,Frame,以及Note(带offset)的F1 score相较于之前的state-of-the-art都有足足一倍的提升!!</p><p>本文还提出了一个新的评价指标:note with offset</p><h4 id="3-文章主要方法"><a href="#3-文章主要方法" class="headerlink" title="3.文章主要方法"></a>3.文章主要方法</h4><h5 id="3-1-mel-spectrograms参数"><a href="#3-1-mel-spectrograms参数" class="headerlink" title="3.1 mel-spectrograms参数"></a>3.1 mel-spectrograms参数</h5><p>229 mel-bins, 2048 FFT Window size, 16000Hz采样率.将该频谱结果作为CNN的输入.</p><p><img src="/images/onsets.jpg" alt></p><h5 id="3-2-onset-detector"><a href="#3-2-onset-detector" class="headerlink" title="3.2 onset detector"></a>3.2 onset detector</h5><p>卷积层的输出作为128 units双向LSTM的输入,LSTM后接一个88 维输出的全连接层,88维的输出表示88个钢琴key的onset概率.</p><h5 id="3-3-framewise-detector"><a href="#3-3-framewise-detector" class="headerlink" title="3.3 framewise detector"></a>3.3 framewise detector</h5><p>这个检测器的构成略有不同,首先是卷积层,接一个88维输出的全连接层,这个88维的输出向量会和onset detection端的对88个钢琴key的onset预测向量concatenate成一个176维向量,再过一个88维输出的全连接层.</p><h5 id="3-4-Loss"><a href="#3-4-Loss" class="headerlink" title="3.4 Loss"></a>3.4 Loss</h5><p>总的loss是由onset端和note端两个cross-entrophy组成.</p><p><img src="/images/loss1.png" alt></p><p>$p<em>{min}$和$p</em>{max}$表示MIDI的音高范围,T代表样本中有帧的数目,$I<em>{onset}(p,t)$ 是一个标志值,当在帧t和音高p处有一个真实的onset时,它的值为1.$P</em>{onset}(p,t)$表示模型在帧t和音高p处预测概率表示,CE代表交叉熵.</p><p><img src="/images/130.png" alt></p><p>作者在这里定义了note端frame loss: 当在帧t如果音高p有真实标注值时,$I<em>{frame}(p,t)$是1,$P</em>{frame}(p,t)$则是代表模型预测的帧t处音高p被激活的概率.</p><p><img src="/images/132.png" alt></p><p>值得注意的是,作者为了激励模型对音符起始端的预测准确率,对上面的frame loss加了一个额外的权值.我们记上面的frame loss为$L’<em>{frame}(l,p)$,假设一个音符的onset在帧$t</em>{1}$处,在帧$t<em>{2}$处完成onset,在$t</em>{3}$处结束音符,如果我们给权值向量在音符的初始帧处赋予更高的权值,那么激励模型更加准确的预测音符的起始端.也就能够保留piece中最重要的musical events.</p><p><img src="/images/133.png" alt></p><p>这里c=5.0,作者做了coarse hyperparameter得到的.</p><p>作者将模型继续拓展,增加了一个模型预测每一个onset的velocities,这个模型和其他两个模型相同且包含了同样的卷积层,但是这个模型和其他两个没有联系. </p><p><img src="/images/131.png" alt></p><p>在上述实验中velocity的标签被归一化到了[0,1]间,是一个piece中所有的vecolity都被除以了这个piece中最大的velocity,将归一化后的velocity转换回来使用以下映射.</p><p><img src="/images/134.png" alt></p><p>作者发现在帧上和pitch上做对velocity的评价指标在之前的研究是一片空白,为此作者提出了新的note-level上的precision,recall,F1 scores.</p><p>直接对velocity评价不易,因为不像pitch和帧,velocity没有绝对的意义.比如说两个转录都包含了同一个确定的velocity,如果这两个velocity由某个常数因子偏移或者缩放了,导致每个音符的velocity完全不同,但是这两个转录系统仍然是非常等价的.</p><p>为此作者做了以下处理:先将转录中的真实velocity全部归一化到[0,1],将所有音符根据音高,onset和offset匹配好,为这些匹配好的音符加上真实的velocity和模型估计的velocity,然后做一个线性回归</p><p><img src="/images/135.png" alt></p><p>其中M是匹配的个数,估计出m和b之后,使用这两个参数估计新的$v_{e}$</p><p><img src="/images/136.png" alt></p><p>最后定一个阈值$\tau$=0.1,选取$\begin{array}{l}\left|\widehat{v_e}(i)-v_r(i)\right|&lt;\tau\\end{array}$,这样就消除了偏移或者缩放的问题.</p><p>选取符合条件的匹配,重新计算precision,recall,F1 score.</p><h4 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4.实验结果"></a>4.实验结果</h4><p><img src="/images/137.png" alt></p><p>可以看到Onsets and Frames算法在四类评价指标上在之前的state-of-the-art相比都取得了巨大的提升,甚至在某些指标上取得了100%的提升.</p><p>值得一提的是,这篇文章发在2018年ISMIR上,大约四月截稿,在2018年10月截稿的2019年一篇ICASSP论文”<a href="https://ieeexplore.ieee.org/abstract/document/8683582" target="_blank" rel="noopener">Deep Polyphonic ADSR Piano Note Transcription</a>“,来自奥地利的研究者又在MAPS数据集上刷新了state-of-the-art谷歌brain的人并不服输,还是这篇论文的作者们在2019年ICLR上的一篇论文<a href="https://arxiv.org/abs/1810.12247" target="_blank" rel="noopener">“Enabling Factorized Piano Music Modeling and Generation with the MAESTRO Dataset”</a>又在ICASSP这篇文章上大幅刷新state-of-the-art.有趣的是.这篇文章是2018.10.29提交到arxiv上的,而2019icassp正好是10.29截止.好险,要是再晚一两个月.说不定那篇文章就中不了了.由此也可以看出这个钢琴转录的课题普通课题组绝对不需要做了,浪费时间.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-文章出处&quot;&gt;&lt;a href=&quot;#1-文章出处&quot; class=&quot;headerlink&quot; title=&quot;1.文章出处&quot;&gt;&lt;/a&gt;1.文章出处&lt;/h4&gt;&lt;p&gt;发在2018ISMIR,来自Google Brain团队,&lt;a href=&quot;https://arxiv.or
      
    
    </summary>
    
      <category term="音乐信息检索" scheme="http://yoursite.com/categories/%E9%9F%B3%E4%B9%90%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="piano transcrption" scheme="http://yoursite.com/tags/piano-transcrption/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="paper note" scheme="http://yoursite.com/tags/paper-note/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记(2):Conv1d,RNN,LSTM</title>
    <link href="http://yoursite.com/2019/06/19/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)-Conv1d:RNN:LSTM/"/>
    <id>http://yoursite.com/2019/06/19/Pytorch学习笔记(2)-Conv1d:RNN:LSTM/</id>
    <published>2019-06-19T07:53:48.000Z</published>
    <updated>2019-06-26T08:43:34.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一维卷积"><a href="#一维卷积" class="headerlink" title="一维卷积"></a>一维卷积</h3><p><code>torch.nn.Conv1d</code>(<em>in_channels</em>, <em>out_channels</em>, <em>kernel_size</em>, <em>stride=1</em>, <em>padding=0</em>, <em>dilation=1</em>, <em>groups=1</em>, <em>bias=True</em>, <em>padding_mode=’zeros’</em>)</p><p>这个函数用来对输入张量做一维卷积</p><ul><li>in_channel和out_channel是卷积核个数</li><li>kernel_size是卷积核的大小</li><li>stride是卷积核移动步长, padding是否对输入张量补0</li></ul><p>现在我有一个音频的梅尔频谱数据输入,一个batch为十张频谱, 一张频谱大小为129帧, 频率幅度为128,这个张量表示为(10, 128, 129),</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">input = torch.randn(<span class="number">10</span>, <span class="number">128</span>, <span class="number">129</span>)</span><br><span class="line">m = nn.Conv1d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">4</span>, padding=<span class="number">2</span>)</span><br><span class="line">out = m(input)</span><br><span class="line">print(out.size()) <span class="comment">#(10, 128, 130)</span></span><br></pre></td></tr></table></figure><p>可以看出来上面这个函数只在频谱的时域上进行一维卷积,卷积核大小为4帧,在频域上没有卷积.为什么输出是130,反而多了一帧呢?</p><p>这是因为这个一维卷积函数</p><ul><li>Input(batch_size, Channel_input, length_input)</li><li>Output(batch_size, Channel_output, length_output)</li></ul><p>$L<em>{out}=\lfloor\frac{L</em>{in}+2\times padding-dilation\times(kernel_size-1)-1}{stride}+1\rfloor=\frac{129+2\times2-1\times(4-1)-1}1+1=130$</p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p>结构</p><p><img src="/images/RNN.jpeg" alt></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>torch.nn.RNN</code>(<strong>args<em>, </em></strong>kwargs*)</p><p>这个函数对输入的的sequence施加一个带tanh或者Relu的RNN.对输入的sequence每一个元素,每一层都施加如下计算:</p><ul><li>$h<em>t=tanh(W</em>{hi}xt+b<em>{hi}+W</em>{hh}h<em>{t-1}+b</em>{hh})$</li></ul><p>$h<em>t$是t时刻的隐层状态,$x_t$是t时刻的输入,$h</em>{t-1}$是t-1时刻的隐层状态或者是0时刻的隐层状态.</p><p>参数:</p><ul><li>input_size:输入x的维度</li><li>hidden_size:隐层状态h的维度</li><li>numpy_layers:循环层的数目</li><li>nonlinearity: 非线性变换,可以使tanh或者relu, 默认是tanh</li><li>bias:如果是False,不使用$b<em>{hi}$和$b</em>{hh}$,默认为True</li><li>batch_first: 如果是True,输入和输出张量的形状是{batch,seq,feature}</li><li>bidirectional: 如果是True,那么是一个双向RNN</li></ul><p>输入:input和h_0</p><ul><li>input的形状是{seq_len,batch,input_size},我看大家一般喜欢用{batch,seq_len,input_size}一些</li><li>h_0的形状是(num_layers*num_birections,batch,hidden_size),对batch中每一个元素的初始隐层状态</li></ul><p>输出:output,h_n</p><ul><li>output的形状是(seq_len,batch,num_directions*hidden_size),最后一个RNN层的输出特征(h_t)</li><li>h_n的形状是(num_layers*num_birections,batch,hidden_size),t=seq_len时刻的隐层状态</li></ul><p><strong>Note:h_n和output的关系</strong>:output包括了seq_len中每一个时间点的隐层状态,而h_n是第seq_len时刻的隐层状态,所以output中最后一个元素就是h_n,即output[-1] ==h_n.</p><h4 id="范例代码"><a href="#范例代码" class="headerlink" title="范例代码"></a>范例代码</h4><p>下面是一个pytorch中使用RNN通过Sin来预测Cos</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">TIME_STEP = <span class="number">40</span> <span class="comment"># rnn 时序步长数</span></span><br><span class="line">INPUT_SIZE = <span class="number">1</span> <span class="comment"># rnn 的输入维度</span></span><br><span class="line">DEVICE = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">H_SIZE = <span class="number">128</span> <span class="comment"># of rnn 隐藏单元个数</span></span><br><span class="line">EPOCHS=<span class="number">480</span> <span class="comment"># 总共训练次数</span></span><br><span class="line">h_state = <span class="literal">None</span> <span class="comment"># 隐藏层状态</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(RNN, self).__init__()</span><br><span class="line">        self.rnn = nn.RNN(</span><br><span class="line">        input_size=INPUT_SIZE,</span><br><span class="line">        hidden_size=H_SIZE,</span><br><span class="line">        num_layers=<span class="number">1</span>,</span><br><span class="line">        batch_first=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">        self.out = nn.Linear(H_SIZE, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, h_state)</span>:</span></span><br><span class="line">         <span class="comment"># x (batch, time_step, input_size)</span></span><br><span class="line">         <span class="comment"># h_state (n_layers, batch, hidden_size)</span></span><br><span class="line">         <span class="comment"># r_out (batch, time_step, hidden_size)</span></span><br><span class="line">        r_out, h_state = self.rnn(x, h_state)</span><br><span class="line">        outs = [] <span class="comment"># 保存所有的预测值</span></span><br><span class="line">        <span class="keyword">for</span> time_step <span class="keyword">in</span> range(r_out.size(<span class="number">1</span>)): <span class="comment"># 计算每一步长的预测值</span></span><br><span class="line">            outs.append(self.out(r_out[:, time_step, :]))</span><br><span class="line">        <span class="keyword">return</span> torch.stack(outs, dim=<span class="number">1</span>), h_state</span><br><span class="line">         <span class="comment"># 也可使用以下这样的返回值</span></span><br><span class="line">         <span class="comment"># r_out = r_out.view(-1, 32)</span></span><br><span class="line">         <span class="comment"># outs = self.out(r_out)</span></span><br><span class="line">         <span class="comment"># return outs, h_state</span></span><br><span class="line"></span><br><span class="line">rnn = RNN().to(DEVICE)</span><br><span class="line">optimizer = torch.optim.Adam(rnn.parameters()) <span class="comment"># Adam优化，几乎不用调参</span></span><br><span class="line">criterion = nn.MSELoss() <span class="comment"># 因为最终的结果是一个数值，所以损失函数用均方误差</span></span><br><span class="line"></span><br><span class="line">rnn.train()</span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">0</span>,EPOCHS,<span class="number">2</span>):</span><br><span class="line">    start, end = step * np.pi, (step+<span class="number">2</span>)*np.pi <span class="comment"># 一个时间周期</span></span><br><span class="line">    steps = np.linspace(start, end, TIME_STEP, dtype=np.float32)</span><br><span class="line">    x_np = np.sin(steps)</span><br><span class="line">    y_np = np.cos(steps)</span><br><span class="line">    x = torch.from_numpy(x_np[np.newaxis, :, np.newaxis]) <span class="comment"># shape (batch, time_step, input_size)</span></span><br><span class="line">    y = torch.from_numpy(y_np[np.newaxis, :, np.newaxis])</span><br><span class="line">    prediction, h_state = rnn(x, h_state) <span class="comment"># rnn output</span></span><br><span class="line">    <span class="comment"># 这一步非常重要</span></span><br><span class="line">    h_state = h_state.data <span class="comment"># 重置隐藏层的状态, 切断和前一次迭代的链接</span></span><br><span class="line">    loss = criterion(prediction, y)</span><br><span class="line">    <span class="comment"># 这三行写在一起就可以</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> (step)%<span class="number">20</span>==<span class="number">0</span>: <span class="comment">#每训练20个批次可视化一下效果，并打印一下loss</span></span><br><span class="line">        print(<span class="string">"EPOCHS: &#123;&#125;,Loss:&#123;:4f&#125;"</span>.format(step,loss))</span><br><span class="line">        plt.plot(steps, y_np.flatten(), <span class="string">'r-'</span>)</span><br><span class="line">        plt.plot(steps, prediction.data.numpy().flatten(), <span class="string">'b-'</span>)</span><br><span class="line">        plt.draw()</span><br><span class="line">        plt.pause(<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><p>训练到460epoch, loss0.000313,可以看到已经完全拟合了</p><p><img src="/images/RNN480.png" alt></p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/images/LSTM.jpeg" alt></p><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><p><code>torch.nn.LSTM</code>(<strong>args<em>, </em></strong>kwargs*)</p><p>这个函数对输入的sequence施加一个多层的长短周期记忆RNN.对输入的sequence的每一个元素,每一层都施加如下计算.</p><ul><li>$f<em>t=\sigma(W</em>{fi}\;x<em>t+b</em>{fi}+W<em>{fh}h</em>{t-1}+b_{fh})$</li><li>$i<em>t=\sigma(W</em>{ii}\;x<em>t+b</em>{ii}+W<em>{ih}h</em>{t-1}+b_{if})$</li><li>$g<em>t=\tan h(W</em>{gi}\;x<em>t+b</em>{gi}+W<em>{gh}h</em>{t-1}+b_{gh})$</li><li>$o<em>t=\sigma(W</em>{oi}\;x<em>t+b</em>{oi}+W<em>{oh}h</em>{t-1}+b_{oh})$</li><li>$c<em>t=f_t\ast c</em>{t-1}+i_t\ast g_t$</li><li>$h_t=\tan h(c_t)\ast o_t$</li></ul><p>$h<em>t$是t时刻的隐层状态,$c_t$是t时刻的细胞状态,$x_t$是t时刻的输入,$h</em>{t-1}$是t-1时刻的隐层状态或者是0时刻的隐层状态.$i_t$,$f_t$,$g_t$,$o_t$是输入门,忘记门,细胞门,输出门.$\sigma$是sigmoid函数,*是元素乘积</p><p>LSTM函数的参数和RNN都是一致的,区别在于输入输出不同,从上面的简图可以看出,LSTM多了一个细胞的状态,所以每一个循环层都增加了一个细胞状态的输出.</p><p>输入:input,(h_0,c_0)</p><p>input的形状和RNN的一样,都是(seq_len,betch,input_size)</p><p>h_0:(num_layers*numpy_directions,batch,hidden_size),对batch中每一个元素的初始隐层状态</p><p>c_0:(num_layers*numpy_directions,batch,hidden_size),对batch中的每一个元素的初始细胞状态</p><p>输出:output,(h_n,c_n)</p><p>output的形状和RNN一样,都是(seq_len,batch,num_directions*hidden_size),最后一个LSTM层的输出特征(h_t)</p><p>h_n:(num_layers*numpy_directions,batch,hidden_size),t=seq_len时刻的隐层状态</p><p>c_n:(num_layers*numpy_directions,batch,hidden_size),t=seq_len时刻的细胞状态</p><h4 id="范例代码-1"><a href="#范例代码-1" class="headerlink" title="范例代码"></a>范例代码</h4><p>还是使用LSTM通过Sin来预测Cos</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">TIME_STEP = <span class="number">30</span> <span class="comment"># rnn 时序步长数</span></span><br><span class="line">INPUT_SIZE = <span class="number">1</span> <span class="comment"># rnn 的输入维度</span></span><br><span class="line">DEVICE = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">H_SIZE = <span class="number">64</span> <span class="comment"># of rnn 隐藏单元个数</span></span><br><span class="line">EPOCHS=<span class="number">2000</span> <span class="comment"># 总共训练次数</span></span><br><span class="line">h_state = <span class="literal">None</span> <span class="comment"># 隐藏层状态</span></span><br><span class="line">c_state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(RNN, self).__init__()</span><br><span class="line">        self.rnn = nn.LSTM(</span><br><span class="line">        input_size=INPUT_SIZE,</span><br><span class="line">        hidden_size=H_SIZE,</span><br><span class="line">        num_layers=<span class="number">1</span>,</span><br><span class="line">        batch_first=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">        self.out = nn.Linear(H_SIZE, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">         <span class="comment"># x (batch, time_step, input_size)</span></span><br><span class="line">         <span class="comment"># h_state (n_layers, batch, hidden_size)</span></span><br><span class="line">         <span class="comment"># r_out (batch, time_step, hidden_size)</span></span><br><span class="line">        r_out, (h_state,c_state) = self.rnn(x)</span><br><span class="line">        outs = [] <span class="comment"># 保存所有的预测值</span></span><br><span class="line">        <span class="keyword">for</span> time_step <span class="keyword">in</span> range(r_out.size(<span class="number">1</span>)): <span class="comment"># 计算每一步长的预测值</span></span><br><span class="line">            outs.append(self.out(r_out[:, time_step, :]))</span><br><span class="line">        <span class="keyword">return</span> torch.stack(outs, dim=<span class="number">1</span>), h_state, c_state</span><br><span class="line">        <span class="comment"># 也可使用以下这样的返回值</span></span><br><span class="line">        <span class="comment"># r_out = r_out.view(-1, 64)</span></span><br><span class="line">        <span class="comment"># outs = self.out(r_out)</span></span><br><span class="line">        <span class="comment"># return outs, h_state, c_state</span></span><br><span class="line"></span><br><span class="line">rnn = RNN().to(DEVICE)</span><br><span class="line">optimizer = torch.optim.Adam(rnn.parameters()) <span class="comment"># Adam优化，几乎不用调参</span></span><br><span class="line">criterion = nn.MSELoss() <span class="comment"># 因为最终的结果是一个数值，所以损失函数用均方误差</span></span><br><span class="line"></span><br><span class="line">rnn.train()</span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">0</span>,EPOCHS,<span class="number">2</span>):</span><br><span class="line">    start, end = step * np.pi, (step+<span class="number">2</span>)*np.pi <span class="comment"># 一个时间周期</span></span><br><span class="line">    steps = np.linspace(start, end, TIME_STEP, dtype=np.float32)</span><br><span class="line">    x_np = np.sin(steps)</span><br><span class="line">    y_np = np.cos(steps)</span><br><span class="line">    x = torch.from_numpy(x_np[np.newaxis, :, np.newaxis]) <span class="comment"># shape (batch, time_step, input_size)</span></span><br><span class="line">    y = torch.from_numpy(y_np[np.newaxis, :, np.newaxis])</span><br><span class="line">    prediction, h_state,c_state = rnn(x) <span class="comment"># rnn output</span></span><br><span class="line">    <span class="comment"># 这一步非常重要</span></span><br><span class="line">    <span class="comment"># h_state = h_state.data # 重置隐藏层的状态, 切断和前一次迭代的链接</span></span><br><span class="line">    <span class="comment"># c_state = c_state.data</span></span><br><span class="line">    loss = criterion(prediction, y)</span><br><span class="line">    <span class="comment"># 这三行写在一起就可以</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> (step)%<span class="number">20</span>==<span class="number">0</span>: <span class="comment">#每训练20个批次可视化一下效果，并打印一下loss</span></span><br><span class="line">        print(<span class="string">"EPOCHS: &#123;&#125;,Loss:&#123;:4f&#125;"</span>.format(step,loss))</span><br><span class="line">        plt.plot(steps, y_np.flatten(), <span class="string">'r-'</span>)</span><br><span class="line">        plt.plot(steps, prediction.data.numpy().flatten(), <span class="string">'b-'</span>)</span><br><span class="line">        plt.draw()</span><br><span class="line">        plt.pause(<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><p>训练到1980epoch, loss0.000004,可以看到已经完全拟合了.</p><p><img src="/images/LSTM2000.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一维卷积&quot;&gt;&lt;a href=&quot;#一维卷积&quot; class=&quot;headerlink&quot; title=&quot;一维卷积&quot;&gt;&lt;/a&gt;一维卷积&lt;/h3&gt;&lt;p&gt;&lt;code&gt;torch.nn.Conv1d&lt;/code&gt;(&lt;em&gt;in_channels&lt;/em&gt;, &lt;em&gt;out_cha
      
    
    </summary>
    
      <category term="Pytorch" scheme="http://yoursite.com/categories/Pytorch/"/>
    
    
      <category term="Conv1d" scheme="http://yoursite.com/tags/Conv1d/"/>
    
      <category term="RNN" scheme="http://yoursite.com/tags/RNN/"/>
    
      <category term="LSTM" scheme="http://yoursite.com/tags/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>2019.2-2019.6科研总结</title>
    <link href="http://yoursite.com/2019/05/31/2019-2-2019-6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/31/2019-2-2019-6总结/</id>
    <published>2019-05-31T04:29:43.000Z</published>
    <updated>2019-05-31T04:33:43.594Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>今天是五月三十一日，还有四十天来到复旦就快一年了，研一下学期到今天也有三个多月了，总结一下这个学期做了什么。</p><h4 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h4><p>从2.14日回来学校之后，总结了一下上学期看了论文。然后想收集million songs dataset的audio，以前7digital是提供这些歌曲的前三十秒预览的，然后我在找的时候发现7digital早就不提供这个API了。花了几天功夫还是找不到，同时我在ISMIR谷歌网上论坛上也发现几年前就有人遇到这个难题了，遂放弃。</p><h4 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h4><p>从三月开始我苦于没有数据集训练网络。幸运的是博士师兄花了半个月的时间爬了FMA 数据集，爬到了750个歌手大约14500首歌曲。我一直想收集一些情感标签来预训练一个网络，然后迁移到情感计算领域。于是我就去last.fm上收集每首歌曲听众打上的标签。收集last.fm上的标签可以调用<a href="https://www.last.fm/api" target="_blank" rel="noopener">last.fm的API</a>，但是这里还要学习一些python中网络编程的知识，还要将last.fm返回的标签转换格式保存在文件里面。正准备自己造轮子的时候，我发现了一个三方的python接口<a href="https://github.com/pylast/pylast" target="_blank" rel="noopener">pylast</a>，借助这个接口可以简单访问last.fm网站上的数据。</p><p>把这个库设置好，我使用<a href="https://eyed3.readthedocs.io/en/latest/" target="_blank" rel="noopener">eyeD3</a>提取这些歌曲MP3里面的metadata中的<strong>歌曲名字</strong>和<strong>歌手名字</strong>，这两个是提供给last.fm API的两个索引参数，开始跑收集标签的程序时我发现很多歌曲返回的标签都是空的数组，非常奇怪，这出乎了我的意料。然后我就自己手动的去验证这些收集不到听众标签的歌曲，结果首先发现这些歌曲的歌手要么不知名或者音乐风格小众，导致只有很少的播放记录，其次就是很多歌手虽然有10首歌，但是每首歌受听众欢迎的程度不同。这两个原因导致很多歌曲没有听众标签。这样的歌曲在FMA里面有很多，这会导致我最后根本收集不到多少有对应标签的歌曲。为什么FMA里面有很多这样的歌曲，那这就要考虑音乐版权的问题了，比如说Taylor Swift很火，她的歌肯定是不可能收录到FMA数据集中的。可能只是一些不知名的歌手，自由创作歌手愿意授权给FMA</p><p>于是我转换了一种思路，收集歌手的标签，可能一个歌手的一首歌收集对应的标签太少，那么我转而收集这个歌手的标签，如果这个歌手的歌曲标签收集不到，那么这个歌手对应的标签能够有更大可能搜集到。最终我收集到了大概350个艺术家的标签，使用<a href="https://github.com/keunwoochoi/MSD_split_for_tagging/blob/master/README.md" target="_blank" rel="noopener">Choi</a>筛选的标签进行过滤得到一个50维的稀疏向量作为标签。每个艺术家有一个100个30秒clips。总共35000首歌，足够用来训练了。</p><p>我先训练了一个五层的卷积神经网络来做音乐自动标注，使用的评价指标是AUC，非常奇怪的是，我轻松的就将AUC在训练集上训到90%，然后将这个网络作为特征提取器转移到情感分类任务上时发现，分类效果和随机分类没有什么差别。这个idea宣告失败。</p><p>后来我四月在做另一个思路时我突然发现失败的原因可能是这个：由于我选用的网络是使用三秒的音频的梅尔频谱作为输入，这里我犯了一个错误，我事先将这个三十秒的clips直接按顺序划分成了十段三秒的音频，这样其实是不妥的，我应该随机的在这个三十秒的音频里选择一个帧作为起点，往后截取出三秒作为神经网络的输入，通过这样处理，那么可以增加很多样本。之前很轻松的能够训到90%的AUC，可能是这个原因导致的。</p><h4 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h4><p>可以说三月的实验进展非常不顺利，但是我在总结实验失败的时候又有一个新的idea冒出来，实验进展非常顺利，我和一位本科学妹一起合作，一个月就把实验全部做好。</p><p>这一部分日后论文发表了再赘述。</p><h4 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h4><p>五月的前十天我在看了很多文献，这里主要是想motivation，总结实验，做好在组会上要讲的PPT。组会开完之后，我们又找了一个新的数据集补了一组实验，汇报过老师之后就开始写论文，这个时候非常尴尬，因为ISMIR会议在四月截止了，而ICASSP要等到10月才截止，所以论文投稿还要很长一段时间。整个五月后面的时间我都在写论文，整理代码。到今天，终于把论文的初稿写出来了，不得不说，写论文真的是一件非常困难的事情。</p><h4 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h4><p>忙了这三个月以后，终于能歇息一会了。</p><p>接下来我也得想想下一步做什么课题，同时在未来的三个月想学一点自己想学的东西。C++？Java？Leetcode？补深度学习知识？读几本自己喜欢的课外书？ 都可以啊哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;今天是五月三十一日，还有四十天来到复旦就快一年了，研一下学期到今天也有三个多月了，总结一下这个学期做了什么。&lt;/p&gt;
&lt;h4 id=&quot;二月&quot;
      
    
    </summary>
    
      <category term="科研生活" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Research" scheme="http://yoursite.com/tags/Research/"/>
    
  </entry>
  
  <entry>
    <title>Recommending music on Spotify with deep learning</title>
    <link href="http://yoursite.com/2019/05/24/recommending-music-on-Spotify-with-deep-learning/"/>
    <id>http://yoursite.com/2019/05/24/recommending-music-on-Spotify-with-deep-learning/</id>
    <published>2019-05-24T11:21:18.000Z</published>
    <updated>2019-06-26T07:53:58.569Z</updated>
    
    <content type="html"><![CDATA[<p>August 05, 2014</p><p><a href="http://benanne.github.io/2014/08/05/spotify-cnns.html" target="_blank" rel="noopener">这篇博客做的工作非常impressive</a>，我花了陆陆续续大概一周之间将它翻译成中文。作者是比利时根特大学毕业，博士期间一直在做music information retrieval的工作，现在他是Deepmind的一名研究科学家。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今年夏天，我在纽约Spotify实习，我的实习工作是使用卷积神经网络基于音乐内容做音乐推荐，在这篇博客中，我会解释我的方法和展示一些初步的结果。</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>这篇博客很长，这里提供一个博客各个部分的一些概览。如果你想跳过一些部分，直接在下面选择章节标题就可以到达。</p><ul><li><p><a href="#1">协同过滤</a></p><p>非常简单的介绍一下协同过滤的优缺点</p></li><li><p><a href="#2">基于内容的推荐</a></p><p>当没有可用的数据时该如何做？</p></li><li><p><a href="#3">使用深度学习来预测用户的偏好</a></p><p>基于音乐音频信号的音乐推荐</p></li><li><p><a href="#3">拓展部分</a></p><p>我在Spotify训练的网络细节</p></li><li><p><a href="#5">分析：卷积神经网络学到了什么？</a></p><p>当使用很多音乐音频样本来训练卷积神经网络时，它学到了什么有关于音乐的东西？</p></li><li><p><a href="#6">这项研究能够用来做什么?</a></p><p>潜在的应用</p></li><li><p><a href="#7">未来工作</a></p></li><li><p><a href="#8">总结</a></p></li></ul><h3 id="1">Collaborative filtering</h3><p>Spotify传统的音乐推荐非常依赖于协同过滤算法来提升推荐准确度。协同过滤的主要思想是从用户的历史行为数据决定用户的偏好。比如说，如果两个用户听了大量相同的歌曲，那么这两位用户的音乐品味可能是相似的，如果两首歌被相同的用户群体听过，那么这两首歌听起来也是相似的。这种信息能够用来做推荐</p><p>纯粹的协同过滤方法不使用任何和被推荐物品<strong>内容</strong>有关的信息，只使用和被推荐物品有关的消费行为信息，换句话说，这些信息是与被推荐物品内容无关的。这使得这种方法能够被广泛使用：同样的模型能够被用来推荐书，电影，音乐等。</p><p>不幸的是，这种方法也被证明有很大的缺陷。由于这种方法非常依赖于用户的行为数据，越流行的物品比不那么流行的物品会被更加容易被推荐，因为对于流行的物品来说，有更多的可用的用户行为数据。这个问题通常不是我们想遇到的。同样出于这个原因，推荐的物品可能让用户觉得无聊和重复的。</p><p>这种方法存在另外一个问题在因为推荐上尤为明显。那就是有着相似用户行为的物品往往内容却非常不相同(the heterogeneity of content with similar usage patterns)。比如说，用户可能一次收听一整张专辑，但是一张专辑也许包括intro tracks，outro tracks，interludes，cover songs，remixes。</p><p>但是最大的问题是新的和不流行的歌曲不能够被推荐，如果没有可用的用户行为数据分析，那么协同过滤算法就会失效。这也就是所谓的冷启动问题(cold-start problem ). 我们想要能够推荐刚刚发布的音乐作品，我们想要给用户推荐他们不知道的非常棒的乐队，想要完成这个目标，我们需要用不同的方法！</p><h3 id="2">Content-based recommendation</h3><p>最近，Spotify饶有兴趣地想要整合其他信息源进入他们的推荐系统当中达缓解一些上述问题。这也被Spotify几个月前收购了音乐智能平台The Echo Nest所证明，有非常多不同种类和音乐相关的信息可以被推荐系统利用：tags，歌手和专辑信息，歌词，从web端挖掘的文本信息，甚至是音频信号本身。</p><p>对于以上的所有信息，大概音频信号本身是最难有效使用的，一方面music audio之间有巨大的语义鸿沟，另一方面，音乐的不同方面都会影响用户的偏好。一些信息能够很容易从音频信号中提取出来，比方说音乐的流派和所使用的乐器。其它的就有点困难，比如说音乐的情感，发行的年份，还有一些是不可能从音频本身提取出来的，比如说歌手的地理位置和歌词主题。</p><p>抛开以上这些难点，很明显的是歌曲本身很大程度上会决定用户是否喜欢听这首歌，所以通过分析音频信号来预测一首歌是否会被喜欢是一个很好的idea。</p><h3 id="3">predicting listening preference with deep learning</h3><p>在去年12月，我的同事Aaron van den Oord 和我在NIPS 2013上发了一篇这个主题的文章，名字就是”<a href="https://papers.nips.cc/paper/5004-deep-content-based-music-recommendation" target="_blank" rel="noopener">Deep content-based music recommendation</a>“. 我们想要从音频信号本身来预测用户偏好，通过训练一个回归模型来预测一个之前使用协同过滤算法计算的潜在表征。这种方法能够让我们即使没有用户行为数据，也能够在协同过滤空间里面预测一个表征。你能够从我们的论文题目中推断出来了，这个回归模型就是一个深度神经网络。</p><p>这种方法的根本思想就是许多协同过滤模型把用户和歌曲都投影到一个共同的低维潜在因子空间。这首歌在这个空间里的位置由各种各样能够影响用户偏好的的信息编码。如果两首歌在这个空间里靠得很近，那么他们大概率是相似的，如果一首歌很靠近一个用户，那么这首歌对这个用户可能是一个很好的推荐(假如他们从来没有听过)。如果我们能够从音频来预测这首歌曲在这个空间里的位置，那么就能在没有用户行为数据的情况下将歌曲推荐给正确的用户。</p><p>在论文中我们使用t-SNE算法将模型预测的表征投影到低维空间。下面你可以看到结果图，相似的歌曲聚集在一起。Rap music 大部分能够在图的左上角找到，电音歌手则聚集在图的底部。</p><p><img src="/images/representation_cnn_project.png" alt></p><h3 id="4">Scaling up</h3><p>论文中深度神经网络包括两层卷积层和两层全连接层，网络的输入时三秒的音频的频谱，为了获得更长音频的表征，我们将音频加上一个三秒的窗，取这些窗的平均的预测表征。</p><p>在Spotify，我能够接触到更大数据集，一堆不同协同过滤算法计算出来得laten factor representations，他们也给了我一个很好的GPU来训练模型，这能够使得我拓展之前的工作，现在我能够训练有七层或者八层的卷积神经网络，使用大得多的中间表征和更多的参数(应该是指更复杂的卷积层)。</p><h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p>下面我会详细介绍尝试过的一个网络结构，它有四个卷积层和三个全连接层。正如你会看到的，用于音频信号的卷积神经网络和传统的应用于计算机视觉任务的网络有一些重要的不同。</p><p><img src="/images/spotify_convnet.png" alt></p><p>这个网络的输入是599帧长和128个mel bins的梅尔频谱，梅尔频谱是一种时频域上的表征，在音频信号上用重叠的窗口做短时傅里叶变换，每一个傅里叶变换产生一帧，然后把这些帧concatenate成一个矩阵就构成了一张频谱，最后对这张频谱转换成梅尔频谱减少维度，幅度上也发生了对数转换。</p><p>卷积层上红色矩形就是卷积核在它们的输入上滑动，使用rectified linear units(ReLU，max(0，x))。注意所有层都是一维卷积，这种卷积只在时间维度上进行卷积，而不是在频域上卷积。尽管在频谱上的时域和频域两个维度上卷积在方法上是可行的，当前我不会这么做。因为频谱上的两个维度有不同的含义，这和图片的例子不同。因此使用经常用在图片上的二维卷积核这是不合理的。</p><p>在卷积层之间使用max-pooing对中间层的表征downsample，为他们增加一些时间不变性，在图中用<strong>MP</strong>标记。我在每一个卷积层上使用4帧大小的的卷积核，出于performance的原因，我在第一二个卷积层之间使用4大小的max-pooling，其它层之间都使用2大小的池化。</p><p>在最后一层卷积层后，我在时间维度上使用全局池化层，这一层能覆盖到整个时间轴，有效地计算在时域上学到的特征，我一共使用了三个池化函数：平均池化，最大值池化，L2正则。</p><p>我这么做的原因是在音频信号中检测到特征的绝对位置和当前的任务尤其不相关。这和图片分类不同，在一张图片中，知道一个被检测到特定特征的大概位置是有用的，比如说，一个判断云的特征更可能在一张图片的顶端被激活，如果它在图片的底部被激活，也许它是检测到了一只羊。对于音乐推荐来说，我们只对音乐中一些特征整体上出现了还是没有出现感兴趣，所以在时域上做全局池化是非常合理的。</p><p>另外一个解决这个问题的方法是像我们NIPS那篇文章一样，在短的音频片段上训练一个神经网络，然后在更长的音频片段上加窗，将每一个窗口的值平均作为特征。然而，将池化整合到网络模型中似乎是一个更好的idea，因为在训练的时候，每一步池化都能够发生。</p><p>这个全局的池化特征然后作为一组带relu激活函数全连接层的输入，在这个网络中，网络的最后一层是作为输出层，用来预测40个由vector_exp算法计算的潜在因子，这个算法是曾经在Spotify所用到的众多协同过滤算法之一。</p><h4 id="training"><a href="#training" class="headerlink" title="training"></a>training</h4><p>训练网络优化的是从协同过滤算法得出潜在因子表征和我们网络从音频信号预测的表征之间的mean square error(MSE)，这些从协同过滤算法得到的表征做了归一化处理，这么做可以减少歌曲流行度的影响(对于很多协同过滤算法模型计算得到的表征往往和歌曲流行度有关)。Dropout在全连接层后用来正则化。</p><p>当前我用的数据集是从100万首流行音乐中间提取的30秒片段，计算出梅尔频谱，我大概用了这数据集的一半(50万)来训练，5000首用来验证，剩下的用来做测试集。在训练的时候，我们使用随机偏移值对频谱进行了修剪达到数据增强的目的。</p><p>这个神经网络使用Theano来搭建，在英伟达GTX 780Ti上使用mini batch梯度下降来优化loss，训练数据加载和数据增强分开实施，也就是说GPU在训练一个batch数据时，下一个batch的数据也在并行加载，总共进行了大约750000次梯度更新。我不记得整个网络大约花了多久训练，所有的步骤大概花了18-36小时</p><h4 id="Variations"><a href="#Variations" class="headerlink" title="Variations"></a>Variations</h4><p>正如我前面提到的，这只是我尝试过的其中一个网络结构，我还尝试了一些别的方法。</p><ul><li>更多层</li><li>使用maxout units作为激活函数，而不是用relu</li><li>使用随机池化而不是最大值池化</li><li>将L2正则整合到网络的输出层</li><li>数据增强在时域上使用了拉伸或者压缩频谱</li><li>将不同协同过滤算法得到的不同表征concatenate</li></ul><p>还有一些方法没有达到我的预期</p><ul><li>从卷积层增加’bypass‘连接到全连接层，（我觉得这有点像ResNet的思想，考虑到这还是14年，作者就已经很超前了），当然作者这里这么做的motivation是他认为底层特征也能够对音乐推荐有作用，但是不幸的是，这种设置非常阻碍训练(可能还是当时的计算能力有限)。</li><li>想mixture density networks一样预测一个表征的条件方差，然后获得一个对预测表征的置信估计，确定哪首歌的潜在因子表征是困难的。然而这会使得训练非常的困难，并且结果的置信度估计不如预期表现得好。</li></ul><h3 id="5">Analysis：what is it learning?</h3><p><strong>接下来就是本篇博客的spotlight部分了，打起精神！！</strong></p><p>现在是非常cool的部分了，<strong>卷积神经网络学到了什么？这些特征看起来像什么？</strong>我使用卷积神经网络来解决这个问题的主要原因是我相信基于音乐内容的推荐是一个包含了多个抽象层面的问题。我希望神经网络的连续层可以递进地学习到更复杂和不变的特征，就像他们在图像分类问题上那样。</p><p>结果就如我所设想的那样，首先，让我们看下第一个卷积层，这里有很多卷积核直接作用在输入的频谱上，这些卷积核很容易可视化，可视化结果如下图，点击这张图可以看到更清晰的版本(5584*562)。负值是红色的，正值是蓝色的，白色的是0.注意每个卷积核只有四帧宽，单个卷积核使用黑红色的线分开。</p><p><img src="/images/filters_total.png" alt></p><p>图注：第一层卷积层学到的特征的可视化，时间轴是水平的，频率轴是垂直的，频率从上至下增加</p><p>从这张表征图，我们能够看到很多卷积核能够学习到和声内容，这些内容在不容频率区域以并列的红色和蓝色带显示。有时候这些带是倾斜向上或向下，表明音调的上升或者下降，这表明这些卷积核能够检测人的歌声。</p><h4 id="Playlists-for-low-level-features-maximal-activation"><a href="#Playlists-for-low-level-features-maximal-activation" class="headerlink" title="Playlists for low-level features: maximal activation"></a>Playlists for low-level features: maximal activation</h4><p><strong>为了能够更好的理解这些卷积核学到的东西，我从测试集上中选择了一些能够最大激活这些卷积核的歌曲制作了一个清单</strong>，下面是一些例歌，第一层有256个卷积核，我用0-255随机的标上序号，这些序号是无序的。</p><p>这些歌曲清单包括那些被分析的歌曲，这些30秒的歌曲能够最大地激活一个给定的卷积核。我从第一个卷积层中选择了一些有趣的卷积核，并且计算他们学到的表征，然后在筛选出在整个测试集上最大的激活。注意你应该听歌曲的中间部分来听这些卷积核从中学到了什么，因为这一部分的音频内容被选中分析。</p><p>下面每个spotify播放清单都有十首歌曲，他们中的一些因为版权问题可能不是在所有国家都能听。</p><blockquote><p><strong>这些歌曲的清单我没有设置了，大家想听的话可以去这篇博客原来的地方听</strong></p></blockquote><p><img src="/images/feature_closeup_max.png" alt="卷积核14，242，250，253的表征特写"></p><p>图注：卷积核14，242，250，253的表征特写</p><ul><li>卷积核14似乎检测到了唱歌中的颤音技巧</li><li>卷积核242似乎检测到了铃声</li><li>卷积核250似乎检测到了vocal thirds， 就是多个歌手在唱同一个内容时，但是音符相差 一个major third(4个半音)</li><li>卷积核253似乎能够检测不容种类的bass和drum的声音</li></ul><p>这几类播放清单里面的歌曲流派相差很不同，<strong>这表明这些卷积核能够学习到一些底层音频信号属性</strong>。</p><h4 id="Playlists-for-low-level-features-average-activation"><a href="#Playlists-for-low-level-features-average-activation" class="headerlink" title="Playlists for low-level features: average activation"></a>Playlists for low-level features: average activation</h4><p>下面的四个播放清单的获得有一点点不同：<strong>我计算了每个卷积核对每首歌曲在时间上的平均表征，然后选择这些平均值里最大的</strong>。这意味着对于这些播放清单，卷积核被三十秒长的歌曲持续激活，这种设置对检测和声模式(harmonic pattern)非常有用。</p><p><strong>这些歌曲的清单我没有设置了，大家想听的话可以去这篇博客原来的地方听</strong></p><p><img src="/images/feature_closeup_mean.png" alt></p><p>图注：卷积核1，2，4，28的表征特写</p><ul><li>卷积核1 能够检测noise和guitar distortion</li><li>卷积核2 能够检测一个特定的音调：low Bb, 似乎有时候他也能够检测低了一个半音的A，因为梅尔频谱的频率分辨率不足以区分这两个音调。</li><li>卷积核4能够检测不同低音的嗡嗡嗡声音</li><li>卷积核28能够检测A和弦，似乎能够检测minor和major两种，所以它也许能够检测A和E调</li></ul><p>我认为非常神奇的是神经网络能够学习检测特定的音调和和弦，我之前认为一首歌曲中特定的音调和和弦并不会真正的影响用户的偏好(注意作者这里的监督标签是协同过滤算法计算出的表征)。我对这个现象有两个假设。</p><ol><li>这个网络学会的检测harmonicity，通过不同的卷积核检测不同种类的harmonic，然后将这些在更高层聚合起来检测不同音调的harmonicity。</li><li>这个网络能够学习某个流派中比其它流派中更加常见的和弦和和弦进程。</li></ol><p>我没有去验证这两种假设，但是似乎后者对网络来说更加困难，所以我认为前者更有可能。</p><h4 id="Playlists-for-high-level-features"><a href="#Playlists-for-high-level-features" class="headerlink" title="Playlists for high-level features"></a>Playlists for high-level features</h4><p>网络中的每一层都将底层作为输入，然后从中提取出更高层的特征，<strong>在顶端的全连接层，也就是输出层之前，这些卷积核对某些子流派歌曲非常具有选择性</strong>，可视化这些卷积核在频谱层面学到了什么不是很麻烦，以下的六个播放清单是能够最大激活这些高层卷积核的歌曲。</p><p><strong>这些歌曲的清单我没有设置了，大家想听的话可以去这篇博客原来的地方听</strong></p><p>很明显的是，每个卷积核能够识别特定的流派，有趣的是一些卷积核，比如说卷积核15似乎是一个多模态的卷积核，它能够被多种风格的音乐激活，这些风格的音乐之间完全没有联系。想必这个卷积核的输出当组合其它卷积核的输出时是非常确定的。</p><p>卷积核37非常有趣，似乎它能识别中文语言，这并非完全不可能，因为中文的音素库和其它语言完全不同，还有一些其它检测语言的卷积核：有一个卷积核能够检测西班牙语唱的rap music。另外一种可能是话语流行音乐有一些和其它音乐截然不同的特点，而这个模型能够检测到。</p><p>我花了一些时间分析前50个卷积核，一些其它的卷积核能够检测lounge，reggae，darkwave，country，metalcore，salsa，Dutch，German carnival music，儿歌，舞曲，vocal trance，朋克，土耳其流行音乐，还有我的最爱”Armin van Buuren”，显然他有非常多的歌曲以至于他能够有自己的卷积核。</p><p>AlexNet已经在许多其它计算机视觉任务上取得巨大成功，基于它的多样性和不变性，似乎这些卷积核除了应用在音乐推荐上预测潜在因子，还能够应用在其它音乐信息检索任务上。</p><h4 id="Similar-based-Playlists"><a href="#Similar-based-Playlists" class="headerlink" title="Similar-based Playlists"></a>Similar-based Playlists</h4><p>预测的潜在因子能够用来找到相似的歌曲下面是一组清单中的歌是通过预测一首给定歌曲的潜在因子，然后在测试集中找到其它歌曲的潜在因子和这首歌曲的余弦距离相近的歌曲，下面每个清单中的第一首歌就是这首查询歌曲。</p><p><strong>这些歌曲的清单我没有设置了，大家想听的话可以去这篇博客原来的地方听</strong></p><p>大多数相似的歌曲对这首查询歌曲的粉丝都是正常的推荐，当然这些清单里的推荐歌曲远远称不上完美。但是考虑到他们仅仅是基于音频信号本身计算出来的，这个结果已经相当可以了。有一个错误的推荐是清单中由John Coltrane唱的”My Favorite Things”, 这首歌的特征出现了几个异常值，Elvis Presley唱的”Crawfish”也是同样如此。这大概因为歌曲在8：40-9：10部分出现了一段非常crazy的萨克斯独奏。分析整首歌或许会得到更好的推荐结果。</p><h3 id="6">What will this be used for?</h3><p>Spotify已经使用了很多不同的信息源和算法加入他们的推荐系统当中，所以我的工作最明显的应用是简单的将它作为一个额外的信息。然而它也能够用来过滤其它推荐算法得到的结果。就如我前面提到的，协同过滤算法往往推荐的歌曲汇总包括intro traks, outro tracks, cover tracks,和remixs，这能够使用基于内容的方法有效地过滤。</p><p>我的方法一个最主要的目标是尽可能地推荐一些新的歌曲和不流行的歌曲，我希望这能够帮助到一些不为人知歌手和将要发行的音乐作品。通过使Spotify能够向合适的观众推荐他们的音乐，它将在一定的程度上提供一个公平竞争的环境。</p><p>非常欣慰的是，这工作中的一部分将准备A/B测试，所以我们能够在实际中发现基于音频的推荐将有所不同，这也是我非常欣慰的事情，这在学校可不是轻松能够做到的事情。</p><h3 id="7">Fueture work</h3><p>其它的Spotify收集的用户反馈是对广播电台上播放的曲目点赞或者点灭。这也是一类极其有用的信息能够决定歌曲是否相似。不幸的是他们同是也是非常noise的，当前我在<a href="https://en.wikipedia.org/wiki/Learning_to_rank" target="_blank" rel="noopener">learning to rank</a>情景下使用这类数据。我也想使用不同的距离衡量学习算法，比如说Drlim。如果我想出了什么好的想法我也许会写另外一篇博客。</p><h3 id="8">Conclusion</h3><p>在这篇博客当中，我总结了我至今为止在Spotify担任机器学习实习生的工作，我介绍了我使用卷积神经网络来做基于音频的音乐推荐，我也给出了一些insight: 神经网络实际上学到了什么。这种方法更多的细节请参照NIPS 2013年论文”<a href="https://papers.nips.cc/paper/5004-deep-content-based-music-recommendation" target="_blank" rel="noopener">Deep content-based music recommendation</a>“</p><p>如果你对深度学习，特征学习，和它们在音乐上的应用感兴趣，你可以看看我的<a href="http://benanne.github.io/research/" target="_blank" rel="noopener">reseach page</a>，那里有我在这个领域做的一些其它工作的总结。如果你对Spotify的音乐推荐方法感兴趣，请参考这写<a href="https://www.slideshare.net/erikbern/music-recommendations-mlconf-2014" target="_blank" rel="noopener">presentation</a>或者<a href="https://erikbern.com/" target="_blank" rel="noopener">Erik Bernhardsson</a>的博客</p><p>Spotify是一个非常适合工作的地方。这里非常崇尚技术的开源(至少他们让我写了这篇博客)，这在别的公司通常是不会允许这么做的。如果你对推荐系统，协同过滤，音乐信息检索，或者你正在寻找<a href="https://www.spotifyjobs.com/search-jobs/" target="_blank" rel="noopener">实习或者永久职位</a>，马上联系他们吧。</p><p>如果你对这篇博客有任何问题，请随时到一下社区给我留言。</p><ul><li>Post on <a href="https://news.ycombinator.com/item?id=8137264" target="_blank" rel="noopener">Hacker News</a></li><li>Post on r/machinelearning(失效)</li><li>Post on the Google+deep learning community(失效)</li><li>Post on the Google+music information retrieval community(失效)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;August 05, 2014&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://benanne.github.io/2014/08/05/spotify-cnns.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇博客做的工作非常impressiv
      
    
    </summary>
    
      <category term="音乐信息检索" scheme="http://yoursite.com/categories/%E9%9F%B3%E4%B9%90%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="music recomendation" scheme="http://yoursite.com/tags/music-recomendation/"/>
    
      <category term="music information retrieval" scheme="http://yoursite.com/tags/music-information-retrieval/"/>
    
      <category term="collaborative filtering" scheme="http://yoursite.com/tags/collaborative-filtering/"/>
    
      <category term="Convolutional Neural Networks" scheme="http://yoursite.com/tags/Convolutional-Neural-Networks/"/>
    
      <category term="good article translation" scheme="http://yoursite.com/tags/good-article-translation/"/>
    
  </entry>
  
  <entry>
    <title>ssh远程登录linux出错解决办法</title>
    <link href="http://yoursite.com/2019/04/02/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95linux%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/02/ssh远程登录linux出错解决办法/</id>
    <published>2019-04-02T03:36:47.000Z</published>
    <updated>2019-04-02T03:39:45.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="用ssh远程登录linux出错解决办法"><a href="#用ssh远程登录linux出错解决办法" class="headerlink" title="用ssh远程登录linux出错解决办法"></a>用ssh远程登录linux出错解决办法</h4><h4 id="1-报错情况"><a href="#1-报错情况" class="headerlink" title="1.报错情况"></a>1.报错情况</h4><blockquote><p>ssh：connect to “my host” port22:Connection refused</p></blockquote><p>从服务器端想要传输文件回本地端时，首先出现这个问题，</p><p>最开始尝试的解决办法是我没有装openssh-server</p><p>于是我用了以下两条命令</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo apt-get purge openssh-server </span><br><span class="line">&gt; sudo apt-get install openssh-server</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后… 就变成了这个报错</p><blockquote><p>mirlab@mirlab-fdu:~/wanglei/fma_dataset$ scp -r /home/mirlab/wanglei/fma_dataset/saved_model mer@10.141.247.205:/home/wanglei/PycharmProjects/fma_dataset<br>mer@10.141.247.205’s password:<br>Permission denied, please try again.<br>mer@10.141.247.205’s password:<br>Permission denied, please try again.<br>mer@10.141.247.205’s password:<br>Permission denied (publickey,password).<br>lost connection</p></blockquote><p>查到原因说是我的sshd-config中没有允许root 用户登录。于是我又打开了/etc/ssh/sshd_config</p><blockquote><p>sudo vi /etc/ssh/sshd_config</p></blockquote><p>将其中的PermitRootLogin设置成了yes</p><blockquote><p>PermitRootLogin yes</p></blockquote><p>还是出现了一样的问题，然后我又继续找，找到一个办法就是在/etc/ssh/sshd_config中加一个设置</p><blockquote><p>AllowUsers  yourusername</p></blockquote><p>这一行命令允许你的服务器连接到username为你上面设置的yourusername，其他的用户会被拒绝。</p><p>别忘了重启ssh服务</p><blockquote><p>service sshd restart</p></blockquote><p>最后在终端打上这行命令即可发现你可以使用ssh连接远程的服务器端了,大功告成了!</p><blockquote><p>ssh yourusername@yourhostname </p></blockquote><h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h4><p>总的来说，我们需要在本地sshd_config中把你想要用的username 加入到AllowUsers中。</p><p>具体流程</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo vi /etc/ssh/sshd_config</span><br><span class="line">&gt; PermitRootLogin yes</span><br><span class="line">&gt; AllowUsers otheruser</span><br><span class="line">&gt; service sshd restart</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;用ssh远程登录linux出错解决办法&quot;&gt;&lt;a href=&quot;#用ssh远程登录linux出错解决办法&quot; class=&quot;headerlink&quot; title=&quot;用ssh远程登录linux出错解决办法&quot;&gt;&lt;/a&gt;用ssh远程登录linux出错解决办法&lt;/h4&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="Linux系统" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux系统" scheme="http://yoursite.com/tags/Linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2019电影盘点</title>
    <link href="http://yoursite.com/2019/04/02/2019%E7%94%B5%E5%BD%B1%E7%9B%98%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/02/2019电影盘点/</id>
    <published>2019-04-02T03:36:06.000Z</published>
    <updated>2019-06-01T08:00:47.888Z</updated>
    
    <content type="html"><![CDATA[<p>人生短暂，看电影也要慎重啊。</p><p>1.流浪地球</p><p>非常好的国产科幻电影，好就好在脑洞的设定，还有就是剧情，演员都基本在线。</p><p>2.飞驰人生</p><p>爆米花电影</p><p>3.阿丽塔战斗天使</p><p>这个是世界的设定很有意思，废铁城和撒冷，在注定废铁城的人们要登上撒冷，毁掉撒冷，就像饥饿游戏的设定一样。</p><p>4.绿皮书</p><p>这部电影处处彰显温情，主题又非常鲜明。是今年不可多得的佳作</p><p>剧中的台词非常考究，能让人醍醐灌顶。</p><p>经典台词：”the world full of lonely people afraid to make the first move!”</p><p>还有托尼说过的：”不管你做什么，都要做到极致，上班就认真工作，笑就尽情大笑，吃东西时就像是最后一餐那样去享受。”</p><p>5.华盛顿邮报</p><p>这部电影基于美国1971年”五角大楼文件泄密案”，剧中的两个主角，一个是华盛顿邮报的主编（汤姆汉克斯），一个是华盛顿邮报的老板(梅丽尔斯特里普)。顶住来自政府，银行，同行施加的压力，毅然决然要向公众披露美国政府卷入越南战争的机密文件。这部电影彰显了美国的价值观，那就是出版自由，新闻自由，“free the press”的口号也在剧中出现。</p><p>6.复仇者联盟</p><p>女朋友公司给的电影票。挺好看的，剧情方面感觉中上，结局方面令人满意。钢铁侠终于可以休息了，美国队长终于能够为自己的人生做一次选择了。</p><p>7.哥斯拉2</p><p>可爱的女朋友公司发了电影票，可怜的她只来看了个结局。而我全程看完了，感觉很一般的怪兽电影，和哥斯拉1一样。唯一好评是最后女猪脚终于良心发现，慷慨送死以弥补她的令人瞠目结舌的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生短暂，看电影也要慎重啊。&lt;/p&gt;
&lt;p&gt;1.流浪地球&lt;/p&gt;
&lt;p&gt;非常好的国产科幻电影，好就好在脑洞的设定，还有就是剧情，演员都基本在线。&lt;/p&gt;
&lt;p&gt;2.飞驰人生&lt;/p&gt;
&lt;p&gt;爆米花电影&lt;/p&gt;
&lt;p&gt;3.阿丽塔战斗天使&lt;/p&gt;
&lt;p&gt;这个是世界的设定很有意思，
      
    
    </summary>
    
      <category term="人生之旅" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>pytorch中如何加载训练数据</title>
    <link href="http://yoursite.com/2019/03/29/pytorch%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2019/03/29/pytorch中如何加载训练数据/</id>
    <published>2019-03-29T14:01:57.000Z</published>
    <updated>2019-06-16T09:25:26.101Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-为什么不需要自己写加载方法"><a href="#1-为什么不需要自己写加载方法" class="headerlink" title="1.为什么不需要自己写加载方法"></a>1.为什么不需要自己写加载方法</h4><p>pytorch中提供了两个类用于训练数据的加载，分别是 torch.utils.data.Dataset和 torch.utils.data.DataLoader 。不像torchvision中集合了很多常用的计算机视觉的常用数据集，作为在音乐信息检索这方面，数据集要自己设计加载方法。如果每次不同的数据集都要自己写函数加载，</p><ul><li>每次读取代码不能够重用，不同的数据读取代码不同</li><li>自己写的加载函数也会有各种问题，比如说限制数据读取速度，或者当数据集太大，直接加载到字典或者列表中会很占用内存，数据读取阶段也会占用大量时间</li><li>只能单线程读取数据</li></ul><p>这次我做的实验需要加载歌曲的梅尔频谱，每个歌曲的片段为30秒，大约是一个1290*128大小的矩阵。所以这次我决定使用pytorch的Dataset类来加载数据。</p><h4 id="2-Dataset类"><a href="#2-Dataset类" class="headerlink" title="2.Dataset类"></a>2.Dataset类</h4><blockquote><p>class torch.utils.data.Dataset</p></blockquote><p>这个抽象类代表了数据集，任何我们自己设计的数据集类都应该是这个类的子类，继承这个类，重写 <em>_len__() 方法，这个方法是用来获得数据集的大小，和\</em>_getitem__()方法，这个方法用来返回数据集中索引值为0到len(dataset)的元素。</p><ul><li>def __getitem__(self, index): 实现这个函数，就可以通过索引值来返回训练样本数据</li><li>def __len__(self): 实现这个函数，返回数据集的大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dataset</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""An abstract class representing a Dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    All other datasets should subclass it. All subclasses should override</span></span><br><span class="line"><span class="string">    ``__len__``, that provides the size of the dataset, and ``__getitem__``,</span></span><br><span class="line"><span class="string">    supporting integer indexing in range from 0 to len(self) exclusive.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ConcatDataset([self, other])</span><br></pre></td></tr></table></figure><p>如果不重写这两个私有函数，就会触发错误。</p><h4 id="3-定义自己的数据集类"><a href="#3-定义自己的数据集类" class="headerlink" title="3.定义自己的数据集类"></a>3.定义自己的数据集类</h4><p>于是我就针对自己的需求实现了以下的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fma_dataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="comment"># root 是训练集的根目录， mode可选的参数是train，test，validation，分别读取相应的文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, mode)</span>:</span> </span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.root = root + <span class="string">"/fma_"</span> + self.mode</span><br><span class="line">        self.mel_cepstrum_path = self.get_sample(self.root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        sample = np.load(self.mel_cepstrum_path[index])</span><br><span class="line">        data = torch.from_numpy(sample[<span class="number">0</span>])</span><br><span class="line">        target = torch.from_numpy(sample[<span class="number">1</span>].astype(np.float32))</span><br><span class="line">        <span class="keyword">return</span> data, target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">"train"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">23733</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">        <span class="keyword">elif</span> self.mode == <span class="string">"validation"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6780</span>  <span class="comment"># 验证集大小</span></span><br><span class="line">        <span class="keyword">elif</span> self.mode == <span class="string">"test"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3390</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sample</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        cepstrum = []</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir(root):</span><br><span class="line">            <span class="keyword">if</span> entry.is_file():</span><br><span class="line">                cepstrum.append(entry.path)</span><br><span class="line">        <span class="keyword">return</span> cepstrum</span><br></pre></td></tr></table></figure><h4 id="4-DataLoader类"><a href="#4-DataLoader类" class="headerlink" title="4.DataLoader类"></a>4.DataLoader类</h4><blockquote><p><em>class</em><code>torch.utils.data.DataLoader</code><strong>(</strong>dataset<strong>,</strong> <em>batch_size=1**</em>,<strong> <em>shuffle=False</em></strong>,<strong> <em>sampler=None</em></strong>,<strong> <em>batch_sampler=None</em></strong>,<strong> <em>num_workers=0</em></strong>,<strong> <em>collate_fn=<function default_collate></function></em></strong>,<strong> <em>pin_memory=False</em></strong>,<strong> <em>drop_last=False</em></strong>,<strong> <em>timeout=0</em></strong>,<strong> <em>worker_init_fn=None</em></strong>)**</p></blockquote><p>仅仅有通过索引返回训练数据数不够的，我们还需要DataLoad类提供拓展功能。</p><ul><li>可以分批次读取：batch-size</li><li>可以对数据进行shuffle操作</li><li>可以用多个线程来读取数据</li></ul><p>这个类我们不需要实现代码，直接调用，设置好参数就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-为什么不需要自己写加载方法&quot;&gt;&lt;a href=&quot;#1-为什么不需要自己写加载方法&quot; class=&quot;headerlink&quot; title=&quot;1.为什么不需要自己写加载方法&quot;&gt;&lt;/a&gt;1.为什么不需要自己写加载方法&lt;/h4&gt;&lt;p&gt;pytorch中提供了两个类用于训练
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题之路(六)</title>
    <link href="http://yoursite.com/2019/03/24/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF-%E5%85%AD/"/>
    <id>http://yoursite.com/2019/03/24/Leetcode刷题之路-六/</id>
    <published>2019-03-24T12:36:54.000Z</published>
    <updated>2019-06-16T09:28:47.383Z</updated>
    
    <content type="html"><![CDATA[<p>这五道题全部都是和树的遍历有关系，也是非递归的二叉树遍历写法，有前中后序三种遍历，按层遍历。总结如下。</p><h5 id="LeetCode94二叉树的中序遍历"><a href="#LeetCode94二叉树的中序遍历" class="headerlink" title="LeetCode94二叉树的中序遍历"></a>LeetCode94二叉树的中序遍历</h5><p>算法思路：二叉树的前序遍历和中序遍历代码基本一致，不同的地方在于什么时候该访问父节点。非递归的写法主要是使用一个栈来保存已经访问过的结点，其实树的前中后序三种遍历就是深度优先搜索的变形。</p><p>具体的来说，中序遍历一直将访问到的结点入栈，继续访问该结点的左子结点，直到左子结点为空，弹出栈顶结点，访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        seq = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> seq</span><br><span class="line">        <span class="keyword">while</span>((root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) | (len(stack) &gt; <span class="number">0</span>)):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                seq.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure><h5 id="LeetCode144二叉树的前序遍历"><a href="#LeetCode144二叉树的前序遍历" class="headerlink" title="LeetCode144二叉树的前序遍历"></a>LeetCode144二叉树的前序遍历</h5><p>算法思路：前序遍历就是先访问该节点，然后再将该节点的左子节点入栈，如果该节点为空，则弹出栈顶元素，访问右子结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        seq = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span>  <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> seq</span><br><span class="line">        <span class="keyword">while</span>((root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) | (len(stack) &gt; <span class="number">0</span>)):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                seq.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure><h5 id="LeetCode145二叉树的后序遍历"><a href="#LeetCode145二叉树的后序遍历" class="headerlink" title="LeetCode145二叉树的后序遍历"></a>LeetCode145二叉树的后序遍历</h5><p>算法思路：<strong>由于后序遍历是先访问左子结点，再访问右子节点，最后是根节点。但是如果我们按根节点，右子节点，左子节点的顺序访问，然后最后反转过来。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        seq = [] </span><br><span class="line">        stack = [] </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> seq</span><br><span class="line">        <span class="keyword">while</span>((root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)|(len(stack) &gt; <span class="number">0</span> )):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                seq.append(root.val)  <span class="comment"># first visit root node</span></span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right <span class="comment"># second visit rightchild node</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                root = root.left <span class="comment"># third visit leftchild node</span></span><br><span class="line">        <span class="comment"># beacause we visit by order that root,rightchild,left,</span></span><br><span class="line">        <span class="comment"># so we should reverse the final result</span></span><br><span class="line">        <span class="keyword">return</span> seq[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h5 id="LeetCode102二叉树的层次遍历"><a href="#LeetCode102二叉树的层次遍历" class="headerlink" title="LeetCode102二叉树的层次遍历"></a>LeetCode102二叉树的层次遍历</h5><p>算法思路：二叉树的层次遍历实际上是广度优先搜索，在树的搜索过程中，每次都要搜索完该层然后再进入下一层，广度优先搜索的的广度就体现在树的每一层上。<strong>树的层次遍历，我们需要用一个队列来保存当前结点的左右子结点，每次从队列中存储的第一个元素出队，访问该结点，判断是否有左右子结点，如果有就入队，当队列为空则结束了遍历。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        list = []</span><br><span class="line">        seq = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> seq</span><br><span class="line">        list.append(root)</span><br><span class="line">        <span class="keyword">while</span>(len(list) &gt; <span class="number">0</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            length_layer = len(list)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length_layer):</span><br><span class="line">                root = list[<span class="number">0</span>]</span><br><span class="line">                temp.append(root.val)</span><br><span class="line">                <span class="keyword">del</span> list[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    list.append(root.left)</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    list.append(root.right)</span><br><span class="line">            seq.append(temp)</span><br><span class="line">        <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure><h5 id="LeetCode103二叉树的锯齿形层次遍历"><a href="#LeetCode103二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode103二叉树的锯齿形层次遍历"></a>LeetCode103二叉树的锯齿形层次遍历</h5><p>算法思路：这道题和上面那道题非常相似，唯一需要注意的地方在于偶数层的结点应该从右到左访问，奇数层的结点应该从左到右访问。所以我们可以设置一个额外的列表来保存偶数层的结点，在代码中就是temp_list，它的左右在于将偶数层的结点反转过来，然后访问temp_list中的结点。<strong>这里值得注意的是：我们不能够在访问temp_list的结点时候，顺便将该结点的左右子结点入队，这会导致下一层的访问又是从右到左的访问顺序，我们应该按原来树的每一层结构顺序，将结点的左右子结点入队，而不是按反转过来的结点顺序，将结点的左右子结点入队。</strong>我在这里被坑了一个小时，我的天。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        seq = []</span><br><span class="line">        list = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> seq</span><br><span class="line">        list.append(root)</span><br><span class="line">        layer = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(len(list) &gt; <span class="number">0</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">if</span> layer % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                length_layer = len(list)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length_layer):</span><br><span class="line">                    root = list[<span class="number">0</span>]</span><br><span class="line">                    temp.append(root.val)</span><br><span class="line">                    <span class="keyword">del</span> list[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        list.append(root.left)</span><br><span class="line">                    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        list.append(root.right)</span><br><span class="line">                seq.append(temp)</span><br><span class="line">                layer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> layer % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                length_layer = len(list)</span><br><span class="line">                temp_list = list[::<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length_layer):</span><br><span class="line">                    root = temp_list[<span class="number">0</span>]</span><br><span class="line">                    temp.append(root.val)</span><br><span class="line">                    <span class="keyword">del</span> temp_list[<span class="number">0</span>]</span><br><span class="line">                    root = list[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">del</span> list[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        list.append(root.left)</span><br><span class="line">                    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        list.append(root.right)</span><br><span class="line">                seq.append(temp)</span><br><span class="line">                layer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这五道题全部都是和树的遍历有关系，也是非递归的二叉树遍历写法，有前中后序三种遍历，按层遍历。总结如下。&lt;/p&gt;
&lt;h5 id=&quot;LeetCode94二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#LeetCode94二叉树的中序遍历&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>她</title>
    <link href="http://yoursite.com/2019/03/19/%E5%A5%B9/"/>
    <id>http://yoursite.com/2019/03/19/她/</id>
    <published>2019-03-19T14:46:05.000Z</published>
    <updated>2019-05-30T02:22:43.031Z</updated>
    
    <content type="html"><![CDATA[<p>我认识了一个女孩子，她和我一样爱笑。她对我很好，虽然我们之前从来没有见过，我们是在不同的地方长大，上不同的学校，成长经历也不同，但是我们却能够在台湾认识。我很笃定对于我来说她是对的人，但是现在我们还没有真正成为恋人，我决定不会再逼她一点点，两个人有两个人自己的判断，我相信很快就会有结果吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我认识了一个女孩子，她和我一样爱笑。她对我很好，虽然我们之前从来没有见过，我们是在不同的地方长大，上不同的学校，成长经历也不同，但是我们却能够在台湾认识。我很笃定对于我来说她是对的人，但是现在我们还没有真正成为恋人，我决定不会再逼她一点点，两个人有两个人自己的判断，我相信很
      
    
    </summary>
    
      <category term="人生之旅" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之路(五)</title>
    <link href="http://yoursite.com/2019/03/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF-%E4%BA%94/"/>
    <id>http://yoursite.com/2019/03/19/LeetCode刷题之路-五/</id>
    <published>2019-03-19T02:31:04.000Z</published>
    <updated>2019-06-16T09:27:05.411Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode33搜索旋转排序数组"><a href="#LeetCode33搜索旋转排序数组" class="headerlink" title="LeetCode33搜索旋转排序数组"></a>LeetCode33搜索旋转排序数组</h4><p>算法思路：这是一道好题。题目要求算法时间复杂度是O(logn)级别，那显然只能用<strong>二分查找</strong>了，关键在于二分查找算法只能用于有序的排列，而这道题给出的数组并不是有序的序列，在某个点上进行了旋转。<strong>那么我们应该怎么找到有序的子序列呢？</strong></p><p><strong>我们只需要判断序列的第一个值和序列中间值的大小就可以判断。因为这是一个有序的序列的必要条件。</strong></p><p>具体的，先进行判断子序列是否是 有序子序列，然后检查target的值是否在有序子序列的范围之内。不过没有我们就继续找下一个有序的子序列，如果target的值在该有序子序列的范围，就继续在这个有序子序列中使用二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;=high):</span><br><span class="line">            middle = low + ((high-low)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[middle] == target:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[low] &lt;= nums[middle]:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[middle] <span class="keyword">and</span> target &gt;= nums[low]:</span><br><span class="line">                        high = middle - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        low = middle + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt;= nums[high] <span class="keyword">and</span> target &gt; nums[middle]:</span><br><span class="line">                        low = middle + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        high = middle<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="LeetCode34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode34 在排序数组中查找元素的第一个和最后一个位置"></a>LeetCode34 在排序数组中查找元素的第一个和最后一个位置</h4><p>算法思路，这道题还是考察二分查找算法，<a href="https://segmentfault.com/a/1190000008699980" target="_blank" rel="noopener">具体可以看这个链接上的二分查找总结</a>。实际上我们只要找到这个元素的第一个位置就行。然后再进行遍历找到最后一个位置。</p><p>tips：具体的要注意一些特殊例子的判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] ==target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] ！=target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            middle = low + ((high-low)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt;= target:</span><br><span class="line">                high = middle <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = middle + <span class="number">1</span></span><br><span class="line">        index = high + <span class="number">1</span> <span class="keyword">if</span> high != len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[high+<span class="number">1</span>] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = index</span><br><span class="line">            <span class="keyword">while</span>(j &lt; len(nums) <span class="keyword">and</span> nums[index] == nums[j]):</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> [index, j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="LeetCode39组合总和"><a href="#LeetCode39组合总和" class="headerlink" title="LeetCode39组合总和"></a>LeetCode39组合总和</h4><p>算法思路，这道题主要考察最基本的深度优先搜索。题目中说要使数字之和等于target，那么我们使用深度优先搜索遍历所有的情况。</p><p>唯一需要注意的是题目中说candidates中的数字可以无限制的重复被选取，所以我们假设路径中加入了”2”这个结点，从这个结点出来以后我们还是继续可以进入”2”这个结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ength = len(candidates)</span><br><span class="line">        result = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        temp = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        self.DFS(<span class="number">0</span>, candidates, target, sum, result, temp)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self,index,cadidate,target,sum,reauslt,temp)</span>:</span></span><br><span class="line">        length = len(cadidate)</span><br><span class="line">        <span class="keyword">if</span> sum == target:</span><br><span class="line">            reauslt.append(temp.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> index == length <span class="keyword">or</span> sum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp.append(cadidate[index])</span><br><span class="line">        sum += cadidate[index]</span><br><span class="line">        self.DFS(index, cadidate, target, sum, reauslt, temp)</span><br><span class="line">        temp.pop()</span><br><span class="line">        sum -= cadidate[index]</span><br><span class="line">        self.DFS(index+<span class="number">1</span>, cadidate, target, sum, reauslt, temp)</span><br></pre></td></tr></table></figure><h4 id="LeetCode40组合总和二"><a href="#LeetCode40组合总和二" class="headerlink" title="LeetCode40组合总和二"></a>LeetCode40组合总和二</h4><p>算法思路：这一题和上一题的算法思路几乎一样，目前我想到的是我们每次找到一个新的组合，就先判断已有的组合中是否有重复的，但是我觉得我的算法还可以再优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        temp = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.DFS(<span class="number">0</span>, target, sum, candidates, temp, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self,index, target, sum, candidate, temp, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum == target:</span><br><span class="line">            <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                result.append(temp.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; target <span class="keyword">or</span> index == len(candidate):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp.append(candidate[index])</span><br><span class="line">        sum += candidate[index]</span><br><span class="line">        self.DFS(index+<span class="number">1</span>, target, sum, candidate, temp, result)</span><br><span class="line">        temp.pop()</span><br><span class="line">        sum -= candidate[index]</span><br><span class="line">        self.DFS(index+<span class="number">1</span>, target, sum, candidate, temp, result)</span><br></pre></td></tr></table></figure><h4 id="LeetCode41缺失的一个正数"><a href="#LeetCode41缺失的一个正数" class="headerlink" title="LeetCode41缺失的一个正数"></a>LeetCode41缺失的一个正数</h4><p>算法思路：这里有一个很妙的思路：我们先遍历一遍数组，将<strong>值在1和数组长度之间的元素放入下标为该元素值的位置</strong>，然后再遍历一遍数组，检查每个元素的值是否和下标对应，如果没有对应，那么该下标就是缺失的最小正数，如果遍历一遍都是对应好的，那么数组长度+1的元素就是缺失的最小正数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>] != nums[i]):</span><br><span class="line">                    temp = nums[nums[i]<span class="number">-1</span>]</span><br><span class="line">                    nums[nums[i]<span class="number">-1</span>] = nums[i]</span><br><span class="line">                    nums[i] = temp</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j] != j+<span class="number">1</span>:</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode33搜索旋转排序数组&quot;&gt;&lt;a href=&quot;#LeetCode33搜索旋转排序数组&quot; class=&quot;headerlink&quot; title=&quot;LeetCode33搜索旋转排序数组&quot;&gt;&lt;/a&gt;LeetCode33搜索旋转排序数组&lt;/h4&gt;&lt;p&gt;算法思路：这
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之路(四)</title>
    <link href="http://yoursite.com/2019/03/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF-%E5%9B%9B/"/>
    <id>http://yoursite.com/2019/03/19/LeetCode刷题之路-四/</id>
    <published>2019-03-19T02:30:53.000Z</published>
    <updated>2019-06-16T09:28:07.036Z</updated>
    
    <content type="html"><![CDATA[<h4 id="leetcode15三数之和"><a href="#leetcode15三数之和" class="headerlink" title="leetcode15三数之和"></a>leetcode15三数之和</h4><p>算法思路：这道题我开始想到就是要固定一个数，然后要用双指针来做，但是两个指针的移动覆盖所有的数据，这样如何更新我没有想明白。</p><p>这是道好题</p><p>正确的解法应该是先将数组排序，遍历数组，固定一个数，<strong>再用双指针从这个数的右边开始遍历</strong>。如果将双指针从数组的起点和端点开始遍历，会得到很多重复的满足条件的组，因为考虑了重复的组别<strong>。所以这里要能想到将双指针从这个数的右边开始遍历就会避免考虑重复的情况而且能够覆盖到所有的情况</strong>，我画了一个简图解释一下。</p><p><img src="/images/leetcode15.jpeg" alt></p><p><strong>从最底下的5开始看，我们先遍历5右边的，然后从加入4后，重新遍历4以后的情况。重复这样一直到1，我们发现所有的情况都覆盖到了，并且不会考虑重复的组</strong>。</p><p>除此之外 算法还值得注意的地方在于：</p><ul><li>如果三个指针如果指向的当前元素与前一个元素相当，跳出本轮循环，检索下一个。</li><li>固定的指针指向的数如果大于了0，停止，因为三个数之和肯定大于了0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        list = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            low = i+<span class="number">1</span></span><br><span class="line">            high = len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="comment">#避免重复的组</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high):</span><br><span class="line">                value = nums[i] + nums[low] + nums[high]</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">                    list.append([nums[i], nums[low], nums[high]])</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high <span class="keyword">and</span> nums[low] == nums[low<span class="number">-1</span>]): <span class="comment"># 避免重复的组</span></span><br><span class="line">                        low += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span>(high &gt; low <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]): <span class="comment"># 避免重复的组</span></span><br><span class="line">                        high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h4 id="leectcode16最接近三数之和"><a href="#leectcode16最接近三数之和" class="headerlink" title="leectcode16最接近三数之和"></a>leectcode16最接近三数之和</h4><p>算法思路：这道题和三数之和思路与很像，唯一的不同点就是要在遍历的过程中要记录和target最接近的三数之和，如何衡量接近，用绝对值就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        count = <span class="number">9223372036854775807</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-2</span>):</span><br><span class="line">            low = i+<span class="number">1</span></span><br><span class="line">            high = length<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                value = nums[i] + nums[low] + nums[high]</span><br><span class="line">                <span class="keyword">if</span> (abs(value - target) &lt; abs(count - target)):</span><br><span class="line">                    count = value</span><br><span class="line">                <span class="keyword">if</span> value == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> value &gt; target:</span><br><span class="line">                        high -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> value &lt; target:</span><br><span class="line">                        low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="leetcode18四数之和"><a href="#leetcode18四数之和" class="headerlink" title="leetcode18四数之和"></a>leetcode18四数之和</h4><p>算法思路：和三数之和基本是一样的，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        list = []</span><br><span class="line">        <span class="keyword">if</span> length &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> list</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-3</span>):</span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="comment">#这里要注意i &gt; 0的条件</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(left, length<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; left <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]: <span class="comment"># 同样这里要注意j &gt; left的条件</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                middle = j+<span class="number">1</span></span><br><span class="line">                right = length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(middle &lt; right):</span><br><span class="line">                    value = nums[i] + nums[j] +nums[middle] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> target == value:</span><br><span class="line">                        list.append([nums[i], nums[j], nums[middle], nums[right]])</span><br><span class="line">                        middle += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span>(middle &lt; right <span class="keyword">and</span> nums[middle] == nums[middle<span class="number">-1</span>]):</span><br><span class="line">                            middle += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span>(middle &lt; right <span class="keyword">and</span> nums[right] == nums[right +<span class="number">1</span>]):</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> target &lt; value:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        middle += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h4 id="leetcode11乘最多水的容器"><a href="#leetcode11乘最多水的容器" class="headerlink" title="leetcode11乘最多水的容器"></a>leetcode11乘最多水的容器</h4><p>算法思路，如果能想到用双指针法从数组的两边开始检索，当两指针指向的矩形两边，移动较短的两边可能增加矩形的面积，而移动较长的边注定会减少矩形的面积。这道题就解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(height) <span class="number">-1</span></span><br><span class="line">        max_Area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high):</span><br><span class="line">            <span class="comment"># reauslt = height[low] if height[low] &lt; height[high] else height[high]</span></span><br><span class="line">            max_Area = max(max_Area, min(height[low],height[high])*(high-low))</span><br><span class="line">            <span class="keyword">if</span> height[low] &lt; height[high]:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_Area</span><br></pre></td></tr></table></figure><h4 id="leetcode31下一个排列"><a href="#leetcode31下一个排列" class="headerlink" title="leetcode31下一个排列"></a>leetcode31下一个排列</h4><p>这道题我真的要爆粗了，用评论中的一句话来说”就是这道题的每个字我都认识，连起来我就不懂了“。</p><p>我说下我理解的题意，所谓全排列就是要从从<strong>数组的右边往左</strong>边开始遍历找第一组$nums[i] &gt; nums[i-1]$。找到之后就开始在这个位置往右边遍历，然后直到找到最小的大于$nums[i-1]$的数$nums[j]$(在我的code里面这个数是$nums\lbrack index_low\rbrack$),交换$nums[i-1]$和$nums[j]$。此时我们还要保证包括$nums[i]$到$nums[lenghth-1]的元素按升序排列。</p><p>最后如果没有找到这一对数字说明整个序列已经按降序排列好了，直接反转就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                index_low = i</span><br><span class="line">                <span class="comment"># 注意下面这个判断条件 中不要写成nums[index_low] &gt;= nums[i-1]!!</span></span><br><span class="line">                <span class="keyword">while</span>(index_low &lt; length <span class="keyword">and</span> nums[index_low] &gt; nums[i<span class="number">-1</span>]):</span><br><span class="line">                    index_low += <span class="number">1</span></span><br><span class="line">                tmp = nums[index_low<span class="number">-1</span>]</span><br><span class="line">                nums[index_low<span class="number">-1</span>] = nums[i<span class="number">-1</span>]</span><br><span class="line">                nums[i<span class="number">-1</span>] = tmp</span><br><span class="line">                i_right = nums[i::]</span><br><span class="line">                i_right.sort()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i_right)):</span><br><span class="line">                    nums[i] = i_right[j]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            nums.reverse()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;leetcode15三数之和&quot;&gt;&lt;a href=&quot;#leetcode15三数之和&quot; class=&quot;headerlink&quot; title=&quot;leetcode15三数之和&quot;&gt;&lt;/a&gt;leetcode15三数之和&lt;/h4&gt;&lt;p&gt;算法思路：这道题我开始想到就是要固定一个数，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之路（三）</title>
    <link href="http://yoursite.com/2019/03/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/19/LeetCode刷题之路（三）/</id>
    <published>2019-03-19T02:28:30.000Z</published>
    <updated>2019-06-16T09:26:39.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode35搜索插入位置"><a href="#LeetCode35搜索插入位置" class="headerlink" title="LeetCode35搜索插入位置"></a>LeetCode35搜索插入位置</h4><p>算法思路：我认为这这道题就是考察二分查找法。</p><p>常见的二分查找考察的方法有：</p><ul><li>给定一个有序的数组，查找target值是否在数组中</li><li>给定一个有序数组，查找target第一次出现的下标（同样也有最后一个出现的下标）</li><li>给定一个有序数组，查找最接近target且大于target的数的下标（最接近target且小于target的数的下标）</li></ul><p><a href="https://segmentfault.com/a/1190000008699980" target="_blank" rel="noopener">这个链接有整理好关于二分查找算法的问题的</a></p><p>说回这道题，这道题需要我们找回数组中target值的索引，如果没有则找到插入位置。其实这个问题就是上面第一个问题—-<strong>给定一个有序的数组，查找target值是否在数组中</strong>，和第三个问题—-<strong>给定一个有序数组，查找最接近target且大于target的数的下标</strong>的结合体。至于应该插在第一位还是最后一位直接可以进行特判（从算法复杂度的角度来说，出现这两种情况是二分查找最差的情况）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line"><span class="comment">#        if target &lt; nums[0]:</span></span><br><span class="line"><span class="comment">#            return 0</span></span><br><span class="line"><span class="comment">#        if target &gt; nums[-1]:</span></span><br><span class="line"><span class="comment">#            return len(nums)</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            middle = low +((high - low)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[middle] == target:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &lt; target:</span><br><span class="line">                low = middle +<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = middle<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> high + <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h4 id="LeetCode38报数"><a href="#LeetCode38报数" class="headerlink" title="LeetCode38报数"></a>LeetCode38报数</h4><p>算法思路：这道题如果读懂了题意，那么就这个问题就简单了。</p><p>题意：比如说“1211”，就是一个1，一个2，两个1组成，所以下一个报数我们要输出“111221”，再比如说“111221”，由三个1，二个2，一个1组成，所以下一个我们要输出”312211“</p><p>每一项报数都是基于前一项的结果生成的。统计相同的数字，当遇到不相同的数字就要输出结果，然后继续统计下一个数字。我的算法需要注意的是在<strong>循环体中当j等于最后一个数了必须要输出当前的字符串</strong>。</p><h4 id="class-Solution"><a href="#class-Solution" class="headerlink" title="class Solution:"></a>class Solution:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        d.setdefault(i, <span class="string">""</span>)</span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="string">'11'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">31</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        tmp_case = <span class="string">""</span></span><br><span class="line">        tmp = d[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(d[i<span class="number">-1</span>])):</span><br><span class="line">            <span class="keyword">if</span> tmp == d[i<span class="number">-1</span>][j]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_case = tmp_case+str(count)+str(tmp)</span><br><span class="line">                tmp = d[i<span class="number">-1</span>][j]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == (len(d[i - <span class="number">1</span>]) - <span class="number">1</span>):</span><br><span class="line">                tmp_case = tmp_case + str(count) + str(tmp)</span><br><span class="line">        d[i] = tmp_case</span><br><span class="line">    <span class="keyword">return</span> d[n]</span><br></pre></td></tr></table></figure><h4 id="LeetCode2两数相加"><a href="#LeetCode2两数相加" class="headerlink" title="LeetCode2两数相加"></a>LeetCode2两数相加</h4><p>算法：就是模拟两个数相加，只是需要考虑不同情况的进位。</p><p>具体的进位有普通的进位；两个数位数一样，最后的一位相加后产生进位；两个数位数不一样，比如123，9740中，“3”和“7”相加产生进位，“9”加上之前进位的“1”还要产生进位。这几种进位情况考虑到了就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        r = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = r</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2):</span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = l1.val + l2.val <span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">else</span> l1.val + l2.val +<span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tmp.val &gt;= <span class="number">10</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                tmp.val -= <span class="number">10</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next </span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span> <span class="keyword">and</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="keyword">return</span> r.next</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = l1.val <span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">else</span> l1.val +<span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tmp.val &gt;= <span class="number">10</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                tmp.val -= <span class="number">10</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">            tmp = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = tmp   </span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val =l2.val <span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">else</span> l2.val +<span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tmp.val &gt;= <span class="number">10</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                tmp.val -= <span class="number">10</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">            tmp = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = tmp  </span><br><span class="line">        <span class="keyword">return</span> r.next</span><br></pre></td></tr></table></figure><h4 id="LeetCode3无重复字符的最长子串"><a href="#LeetCode3无重复字符的最长子串" class="headerlink" title="LeetCode3无重复字符的最长子串"></a>LeetCode3无重复字符的最长子串</h4><p>算法思路：最开始写了个O(n^3)的暴力算法。最后看了下讨论里面发现有一个新的思路：</p><p>将每一个字符加入一个字符串中，依次检查字符串的字符是否已经存在该子串中，没有加加入，当前子串匹配失败时，子串并不需退回去重新匹配，而是将找到当前子串中失配的位置，从下一位重新开始匹配（因为子串中已经存在个相同的字符了，所以从下一个开始匹配） 每次发生失配就返回当前子串的长度。</p><p>tips：当整个字符串检索完毕还要输出还要更新一次<strong>无重复字符串长度</strong>，因为在for循环中只有发生失配才会更新无重复字符串长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        str = <span class="string">''</span>  </span><br><span class="line">        max_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> str:</span><br><span class="line">                str +=  s[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> max_count &lt; len(str):</span><br><span class="line">                    max_count = len(str)</span><br><span class="line">                str = str[str.index(s[i])+<span class="number">1</span>:]</span><br><span class="line">                str += s[i]</span><br><span class="line">        <span class="keyword">if</span> max_count &lt; len(str):</span><br><span class="line">            max_count = len(str)</span><br><span class="line">        <span class="keyword">return</span> max_count</span><br></pre></td></tr></table></figure><h4 id="LeetCode5最长回文子串"><a href="#LeetCode5最长回文子串" class="headerlink" title="LeetCode5最长回文子串"></a>LeetCode5最长回文子串</h4><p>算法思路，这道题有很多种思路，我使用动态规划的方法来解决。</p><p>当我们已经判断一个字符串是一个回文串时,假设我们现在已经获得下标从$i$到$j$的字符串,即$s<em>{i-1,j-1}$是一个回文串,如果$s</em>{i}=\;s<em>{j}$,那么$s</em>{i,j}$就是一个回文串，这种情况适用于回文子串长度大于等于3。当长度为1，和2时得初始化。所以我们可以得到一个这样的状态转移方程：</p><script type="math/tex; mode=display">dp\lbrack i\rbrack\lbrack j\rbrack=\left\{\begin{array}{lc}1&dp\lbrack i+1\rbrack\lbrack j-1\rbrack=0\;and\;s_i=s_j\\0&dp\lbrack i+1\rbrack\lbrack j-1\rbrack\;!=0\;or\;s_i\;!=s_j\end{array}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(length)] <span class="keyword">for</span> j <span class="keyword">in</span> range(length)]</span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length): <span class="comment"># 初始化dp数组</span></span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; length <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[i+<span class="number">1</span>]:</span><br><span class="line">                    dp[i][i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                    <span class="comment">#dp[i+1][i] = 1</span></span><br><span class="line">                    count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> length &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">            <span class="keyword">elif</span> dp[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> len_substring <span class="keyword">in</span> range(<span class="number">3</span>, length+<span class="number">1</span>): <span class="comment"># 枚举每个子串可能的长度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length+<span class="number">1</span>-len_substring):</span><br><span class="line">                j = i+len_substring<span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">        index_i = <span class="number">0</span></span><br><span class="line">        index_j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">                <span class="keyword">if</span> dp[i][j] == <span class="number">1</span>:</span><br><span class="line">                    count = j-i</span><br><span class="line">                    <span class="keyword">if</span> count &gt; max_length:</span><br><span class="line">                        max_length = count</span><br><span class="line">                        index_i = i</span><br><span class="line">                        index_j = j</span><br><span class="line">        <span class="keyword">return</span> s[index_i:index_j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode35搜索插入位置&quot;&gt;&lt;a href=&quot;#LeetCode35搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;LeetCode35搜索插入位置&quot;&gt;&lt;/a&gt;LeetCode35搜索插入位置&lt;/h4&gt;&lt;p&gt;算法思路：我认为这这道题就是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(二)</title>
    <link href="http://yoursite.com/2019/03/05/LeetCode%E5%88%B7%E9%A2%98-%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/03/05/LeetCode刷题-二/</id>
    <published>2019-03-05T11:04:26.000Z</published>
    <updated>2019-06-16T09:30:07.380Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode20有效的括号"><a href="#LeetCode20有效的括号" class="headerlink" title="LeetCode20有效的括号"></a>LeetCode20有效的括号</h4><p>算法思路：这道题就是一个栈就能解决，不多说，碰到’(‘,’[‘,’{‘,入栈，遇到’)’,’]’,’}’。弹出栈顶的元素，匹配是否是一对a，不是则结束输出无效。如果所有的输入完成，栈不为空，输出无效，其它情况都是有效的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: <span class="string">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">        <span class="keyword">if</span> s ==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        char_list = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char ==<span class="string">'('</span> <span class="keyword">or</span> char == <span class="string">'['</span> <span class="keyword">or</span> char == <span class="string">'&#123;'</span>:</span><br><span class="line">                char_list.append(char)</span><br><span class="line">            <span class="keyword">elif</span> char ==<span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> len(char_list) <span class="keyword">and</span> char_list[<span class="number">-1</span>]==<span class="string">'('</span>:</span><br><span class="line">                    char_list.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> len(char_list) <span class="keyword">and</span> char_list[<span class="number">-1</span>]==<span class="string">'['</span>:</span><br><span class="line">                    char_list.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span> len(char_list) <span class="keyword">and</span> char_list[<span class="number">-1</span>]==<span class="string">'&#123;'</span>:</span><br><span class="line">                    char_list.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(char_list) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="LeetCode21合并两个有序链表"><a href="#LeetCode21合并两个有序链表" class="headerlink" title="LeetCode21合并两个有序链表"></a>LeetCode21合并两个有序链表</h4><p>算法思路：使用归并排序的思路，比较两个节点值的大小，小的则插入新的链表中，依次比较，直到一条链表比较完成，将另外一条链表加入到新的链表尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        r = ListNode(<span class="number">0</span>)</span><br><span class="line">        head = r</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                head.next = l1</span><br><span class="line">                head = head.next</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.next = l2</span><br><span class="line">                head = head.next</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            head.next = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            head.next = l2</span><br><span class="line">        <span class="keyword">return</span> r.next</span><br></pre></td></tr></table></figure><h4 id="LeetCode26删除排序数组中的重复项"><a href="#LeetCode26删除排序数组中的重复项" class="headerlink" title="LeetCode26删除排序数组中的重复项"></a>LeetCode26删除排序数组中的重复项</h4><p>算法思路：哈希思想，将出现的元素作为键，将出现次数记录下来。再遍历一边哈希表，将出现次数大于一的key写到nums中。</p><p>tips：题目描述没有说清楚，事实上是需要返回最后nums的长度，不是nums</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        c = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            c.setdefault(i,<span class="number">0</span>)</span><br><span class="line">            c[i] += <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">if</span> c[key] &gt;= <span class="number">1</span>:</span><br><span class="line">                nums[j] = key</span><br><span class="line">                j +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h4 id="LeetCode27移除元素"><a href="#LeetCode27移除元素" class="headerlink" title="LeetCode27移除元素"></a>LeetCode27移除元素</h4><p>算法思路：思路和上题一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        c = &#123;&#125;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i != val:</span><br><span class="line">                c.setdefault(i,<span class="number">0</span>)</span><br><span class="line">                c[i] += <span class="number">1</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        j = count</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,c[key]):</span><br><span class="line">                nums[count<span class="number">-1</span>] = key   </span><br><span class="line">                count -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h4 id="LeetCode28实现strStr"><a href="#LeetCode28实现strStr" class="headerlink" title="LeetCode28实现strStr()"></a>LeetCode28实现strStr()</h4><p>算法思路：这道题就是考察暴力搜索算法和kmp算法的。kmp算法的关键在于理解next数组的生成，next[i]代表子串s[0,…i]的最长相等前后缀的前缀的最后一位下标。</p><p>而next数组的求解过程如下：</p><p>1.初始化next数组，并且j=next[0] = -1。</p><p>2.遍历 i从1到length-1</p><p>3.不断令j = next[j],直到j=-1或者s[i] = s[j+1]</p><p>4.如果s[i] = s[j+1],则next[i] = j+1,否则next[i] = j</p><p>而kmp将模式串和子串进行匹配的过程就和求解next数组一致，唯一不同的就是从模式串的第一位开始，而求解next数组是从第二位开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        len_needle = len(needle)</span><br><span class="line">        len_haystack = len(haystack)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len_needle == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getnext</span><span class="params">(length_pattern,pattern)</span>:</span></span><br><span class="line">            j = - <span class="number">1</span></span><br><span class="line">            next = list(range(len_needle))</span><br><span class="line">            next[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length_pattern):</span><br><span class="line">                <span class="keyword">while</span>(j != <span class="number">-1</span> <span class="keyword">and</span> pattern[i] != pattern[j+<span class="number">1</span>]):</span><br><span class="line">                    j = next[j]</span><br><span class="line">                <span class="keyword">if</span> pattern[i] == pattern[j+<span class="number">1</span>]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                next[i] = j</span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">        next = getnext(len_needle,needle)</span><br><span class="line">        print(next)</span><br><span class="line">        j = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_haystack):</span><br><span class="line">            <span class="keyword">while</span>(j != <span class="number">-1</span> <span class="keyword">and</span> haystack[i] != needle[j+<span class="number">1</span>]):</span><br><span class="line">                j = next[j]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j+<span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == len_needle <span class="number">-1</span>:</span><br><span class="line">                index = i + <span class="number">1</span> - len_needle</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode20有效的括号&quot;&gt;&lt;a href=&quot;#LeetCode20有效的括号&quot; class=&quot;headerlink&quot; title=&quot;LeetCode20有效的括号&quot;&gt;&lt;/a&gt;LeetCode20有效的括号&lt;/h4&gt;&lt;p&gt;算法思路：这道题就是一个栈就能解决，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题（一）</title>
    <link href="http://yoursite.com/2019/02/25/LeetCode%E5%88%B7%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/25/LeetCode刷题（一）/</id>
    <published>2019-02-25T06:38:52.000Z</published>
    <updated>2019-06-16T09:29:30.898Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode1-两数之和-2019-2-17日"><a href="#LeetCode1-两数之和-2019-2-17日" class="headerlink" title="LeetCode1.两数之和(2019.2.17日)"></a>LeetCode1.两数之和(2019.2.17日)</h4><p>直接思路：暴力求解</p><p>从list的两端开始遍历，一直遍历到两端指向同一个元素，如果遍历过程中找到了两个元素之和等于target，返回索引，没有则将首端的指针指向下一个元素。显然算法复杂度为O(n2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length<span class="number">-1</span>,i,<span class="number">-1</span>):</span><br><span class="line">                   <span class="keyword">if</span> nums[i] +nums[j] == target:</span><br><span class="line">                       <span class="keyword">return</span> [i,j]</span><br></pre></td></tr></table></figure><p>改进算法：哈希表</p><p>将每个值的索引存入哈希表中，遍历list的每一元素value，求出target-value值，用这个值去哈希表中寻找对应的索引，找到即返回。算法复杂度为O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            tmp = target - value</span><br><span class="line">            <span class="keyword">if</span> tmp <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">return</span> [i,hashmap[tmp]]</span><br><span class="line">            hashmap[value] = i</span><br></pre></td></tr></table></figure><h4 id="LeetCode7-整数反转"><a href="#LeetCode7-整数反转" class="headerlink" title="LeetCode7.整数反转"></a>LeetCode7.整数反转</h4><p>思路：获得每个位上的数字，具体可以通过%10操作获得个位数字压入队列中，再整除10，再%10获得十位上的数字，直到最后一位，将最后一位压入队列中。如果整数小于0，预先把符号保存下来，正数就不需要管。其次就是120,1230这种最后以0结尾的数，在反转后的数字第一位不能是0，所以我们需要从队列第一个不为0的数字开始恢复，依次将队列里面的数字出队，乘以10，再加上下一个出队数字，再乘以10。最后还要检查反转后的数字是否溢出！有个测试样例1534236469反转后的9646327351就溢出了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = []</span><br><span class="line">        flag1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            x *= <span class="number">-1</span></span><br><span class="line">            flag1 = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">-10</span>&lt;x&lt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> x*flag1</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(flag):</span><br><span class="line">            count = x % <span class="number">10</span></span><br><span class="line">            tmp.append(count)</span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                tmp.append(x)</span><br><span class="line">        newx,counts = (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            <span class="keyword">if</span> tmp[i] != <span class="number">0</span>:</span><br><span class="line">                counts = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(counts, len(tmp)):</span><br><span class="line">            newx += tmp[j]</span><br><span class="line">            <span class="keyword">if</span> j != len(tmp)<span class="number">-1</span>:</span><br><span class="line">                newx *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">-2</span>**<span class="number">31</span>&lt;newx*flag1&lt;<span class="number">2</span>**<span class="number">31</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> newx*flag1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="LeetCode9-回文数"><a href="#LeetCode9-回文数" class="headerlink" title="LeetCode9.回文数"></a>LeetCode9.回文数</h4><p>思路：这其实是一个字符串反转的问题，没什么好说的。python中字符串反转的方法还有递归的思路，用栈，用字符串的分片操作，还有reversed函数一共五种，<a href="https://www.geeksforgeeks.org/reverse-string-python-5-different-ways/" target="_blank" rel="noopener">具体参考这个网址</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x_str = str(x)</span><br><span class="line">        y_str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> x_str:</span><br><span class="line">            y_str = i + y_str</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x_str)):</span><br><span class="line">            <span class="keyword">if</span> x_str[i] == y_str[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == len(x_str):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>LeetCode13.罗马数转换成整数</p><p>思路：这个问题我们可以直接将罗马数字和整数之间转换关系用字典表示，然后再判断”IV”,”IX”,”XL”,”XC”,”CD”,”CM”这六种特殊情况。罗马数字转换到整数直接将每个字符串按位相加就可以了。</p><p>Tips：我的解法有个小问题就是需要注意判断那六种特殊情况是，需要加上”索引i大于0”条件,不加的话，碰到”XXVII“这类会输出25而不是27，因为第一个”X“会被判定为8而不是10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index_dic=&#123;<span class="string">'I'</span>:<span class="number">1</span>,<span class="string">'V'</span>:<span class="number">5</span>,<span class="string">'X'</span>:<span class="number">10</span>,<span class="string">'L'</span>:<span class="number">50</span>,<span class="string">'C'</span>:<span class="number">100</span>,<span class="string">'D'</span>:<span class="number">500</span>,<span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        value_int=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,value <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'V'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] == <span class="string">'I'</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                value_int += <span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'X'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] == <span class="string">'I'</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                value_int += <span class="number">8</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'L'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] == <span class="string">'X'</span><span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                value_int += <span class="number">30</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'C'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] == <span class="string">'X'</span><span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                value_int += <span class="number">80</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'D'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] == <span class="string">'C'</span><span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                value_int += <span class="number">300</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'M'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] == <span class="string">'C'</span><span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                value_int += <span class="number">800</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value_int += index_dic[s[i]]</span><br><span class="line">        <span class="keyword">return</span> value_int</span><br></pre></td></tr></table></figure><h4 id="LeetCode14-最长公共前缀"><a href="#LeetCode14-最长公共前缀" class="headerlink" title="LeetCode14.最长公共前缀"></a>LeetCode14.最长公共前缀</h4><p>算法：我的算法解这道题基于一个前提：<strong>最长的公共前缀的长度必定小于等于字符串数组中最短的那个字符串</strong>。所以先用字符串排序取得最短长度的字符串a。按顺序取出a的每一位，与字符串数组剩下的每一个字符串同样的位置比较是否相等，相等则将这一位存储到list中，继续比较，如果不相等就不需要继续比较了。此时判断list中有0个字符还是大于0个字符，一个字符就返回”“（第一个字符就不相等），多个字符就返回除了当前字符以外别的字符(因为当前字符不相等)。如果最短字符串的所有字符都比较完毕，那么久输出这个最短字符即可。</p><p>注意需要判断[]和[“”]这两种情况。需要进行特判。我的这个算法在时间复杂度上是最优算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: <span class="string">'List[str]'</span>)</span> -&gt; 'str':</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line">            str = <span class="string">""</span></span><br><span class="line">            <span class="keyword">return</span> str</span><br><span class="line">        strs.sort(key=len)</span><br><span class="line">        short_list = []</span><br><span class="line">        <span class="keyword">if</span> strs[<span class="number">0</span>] == <span class="string">""</span>:</span><br><span class="line">            str = <span class="string">""</span></span><br><span class="line">            <span class="keyword">return</span> str</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs[<span class="number">0</span>])):</span><br><span class="line">            tmp=strs[<span class="number">0</span>][i]</span><br><span class="line">            short_list.append(tmp)</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != tmp:</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">and</span> len(short_list)==<span class="number">0</span>:</span><br><span class="line">                str = <span class="string">""</span></span><br><span class="line">                <span class="keyword">return</span> str</span><br><span class="line">            <span class="keyword">elif</span> flag <span class="keyword">and</span> len(short_list) &gt; <span class="number">0</span>:</span><br><span class="line">                str = <span class="string">""</span>.join(short_list[:<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> str</span><br><span class="line">        <span class="keyword">if</span> i == len(strs[<span class="number">0</span>])<span class="number">-1</span>:</span><br><span class="line">            str = <span class="string">""</span>.join(short_list)</span><br><span class="line">            <span class="keyword">return</span> str</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode1-两数之和-2019-2-17日&quot;&gt;&lt;a href=&quot;#LeetCode1-两数之和-2019-2-17日&quot; class=&quot;headerlink&quot; title=&quot;LeetCode1.两数之和(2019.2.17日)&quot;&gt;&lt;/a&gt;LeetCode1.
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>理解Python中的defaultdictt</title>
    <link href="http://yoursite.com/2019/02/25/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84defaultdict/"/>
    <id>http://yoursite.com/2019/02/25/理解Python中的defaultdict/</id>
    <published>2019-02-25T06:35:22.000Z</published>
    <updated>2019-06-16T09:31:08.426Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，如果访问字典中不存在的键时会引发KeyError的异常。但是如果字典中的键如果能够有默认的值有时候是非常方便的。比如以下的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy'</span>,<span class="string">'puppy'</span>,<span class="string">'wesel'</span>,<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy&#125;</span></span><br><span class="line"><span class="string">counts = &#123;&#125;</span></span><br><span class="line"><span class="string">for i in strings:</span></span><br><span class="line"><span class="string">counts[i] += 1</span></span><br></pre></td></tr></table></figure><p>以上这个例子是用来统计单词出现的次数，将单词作为count中的键，单词每出现一次就加1.事实上这段代码是会抛出KeyError的。</p><p>有以下几个办法能够处理这个问题。</p><h5 id="使用判断语句检查"><a href="#使用判断语句检查" class="headerlink" title="使用判断语句检查"></a>使用判断语句检查</h5><hr><p>我们可以在每次取得单词时候，检查这个单词是否在字典中有默认值，没有就赋一个默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy'</span>,<span class="string">'puppy'</span>,<span class="string">'wesel'</span>,<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy&#125;</span></span><br><span class="line"><span class="string">counts = &#123;&#125;</span></span><br><span class="line"><span class="string">for i in strings:</span></span><br><span class="line"><span class="string">if i not in count:</span></span><br><span class="line"><span class="string">counts[i] = 0</span></span><br><span class="line"><span class="string">counts[i] += 1</span></span><br></pre></td></tr></table></figure><h5 id="dict-setdefault-方法"><a href="#dict-setdefault-方法" class="headerlink" title="dict.setdefault()方法"></a>dict.setdefault()方法</h5><hr><p>我们也可以使用dict.setdefault()方法来设置默认值：这个方法结构两个参数，一个是键的名称，另一个是默认值。如果键已经存在字典中就返回它的值，如果没有就将默认值保存并且返回该默认值。用dict.setdefault()重写上面的例子</p><blockquote><p><code>setdefault</code>(<em>key</em>[, <em>default</em>])</p><p>If <em>key</em> is in the dictionary, return its value. If not, insert <em>key</em> with a value of <em>default</em> and return <em>default</em>. <em>default</em> defaults to <code>None</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy'</span>,<span class="string">'puppy'</span>,<span class="string">'wesel'</span>,<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy&#125;</span></span><br><span class="line"><span class="string">counts = &#123;&#125;</span></span><br><span class="line"><span class="string">for i in strings:</span></span><br><span class="line"><span class="string">counts.setdefault(i,0)</span></span><br><span class="line"><span class="string">counts[i] += 1</span></span><br></pre></td></tr></table></figure><p>下面这种方法就是我们本篇博客的主角collections.defaultdict类</p><h5 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h5><hr><blockquote><p><em>class</em> <code>collections.``defaultdict</code>([<em>default_factory</em>[, <em>…</em>]])</p></blockquote><p>defaultdict类返回一个类似于的字典对象，第一个参数给default_factory属性赋值，其它的参数都传递给dict构造器。<strong>通俗来说就是defaultdict类的初始化函数接收一个类型作为参数，当访问的键不存在，实例化一个值作为默认值</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'lei'</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;'lei': []&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'wang'</span>].append(<span class="number">22</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;'lei': [], 'wang': [22]&#125;)</span><br></pre></td></tr></table></figure><p>但是这种使用仅限于直接通过访问字典的键dict[key]或者dict._<em>getitem_</em>()这两种方式，如下面的例子，其它的使用都不行，具体原因稍后介绍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'xu'</span> <span class="keyword">in</span> dd</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.pop(<span class="string">'xu'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#9&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dd.pop(<span class="string">'xu'</span>)</span><br><span class="line">KeyError: <span class="string">'xu'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'xu'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'xu'</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>该类除了接收类型名称来作为初始化函数的参数，还可以使用任何不带参数的可调用函数作为参数，函数的返回结果就作为默认值，这样可以使得默认值的取值更加灵活。下面的例子是介绍这种用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(one)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;function one at <span class="number">0x1101ff2f0</span>&gt;, &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'lei'</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;function one at <span class="number">0x1101ff2f0</span>&gt;, &#123;<span class="string">'lei'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>同样我们也可以使用匿名函数lambda来作为参数，比如说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">strings =&#123;<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy'</span>,<span class="string">'puppy'</span>,<span class="string">'wesel'</span>,<span class="string">'puppy'</span>,<span class="string">'kitten'</span>,<span class="string">'puppy&#125;</span></span><br><span class="line"><span class="string">counts = defaultdict(lambda: 0)</span></span><br><span class="line"><span class="string">for i in strings:</span></span><br><span class="line"><span class="string">counts[i] +=1</span></span><br></pre></td></tr></table></figure><p>为什么defaultdict类可以实现这样的用法呢，因为它支持<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">_<em>missing_</em>()方法</a>。</p><blockquote><p><em>class</em> <code>collections.``defaultdict</code>([<em>default_factory</em>[, <em>…</em>]])</p><p><code>__missing__</code>(<em>key</em>)</p><p>If the <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> attribute is <code>None</code>, this raises a <a href="https://docs.python.org/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> exception with the <em>key</em> as argument.</p><p>If <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> is not <code>None</code>, it is called without arguments to provide a default value for the given <em>key</em>, this value is inserted in the dictionary for the <em>key</em>, and returned.</p><p>If calling <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> raises an exception this exception is propagated unchanged.</p><p>This method is called by the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> method of the <a href="https://docs.python.org/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> class when the requested key is not found; whatever it returns or raises is then returned or raised by <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>.</p><p>Note that <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.__missing__" target="_blank" rel="noopener"><code>__missing__()</code></a> is <em>not</em> called for any operations besides <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>. This means that <code>get()</code> will, like normal dictionaries, return <code>None</code> as a default rather than using<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a></p></blockquote><p> 从第二句我们可以看到如果default<em>factory不是None,调用时会给给定的key一个默认值，这个默认值会保存在key对应的之中，并且被返回。第四句说明这个方法只会被 \</em>_getitem__()方法调用,dict[key]这种形式实际上是_<em>getitem_</em>方法的简化形式。</p><p>当__getitem<em>_()方法访问一个不存在的键时会调用\</em>_missing__()方法获得默认的值，将该键添加到字典中去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(defaultdict.__missing__.__doc__)</span><br><span class="line">__missing__(key) <span class="comment"># Called by __getitem__ for missing key; pseudo-code:</span></span><br><span class="line">  <span class="keyword">if</span> self.default_factory <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">raise</span> KeyError((key,))</span><br><span class="line">  self[key] = value = self.default_factory()</span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h5 id="实现一个defaultdict功能"><a href="#实现一个defaultdict功能" class="headerlink" title="实现一个defaultdict功能"></a>实现一个defaultdict功能</h5><hr><p>在<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" target="_blank" rel="noopener">”dict“</a>python文档中还介绍，如果dict的子类实现了__missing__方法，当访问不存在的键时，dict[key]会调用__missing<em>_（）方法来获得默认值。下面我们可以进一步实验，定义一个dict的子类Missing并且实现\</em>_missing__()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Missing</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self,key)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'missing'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Missing()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'lei'</span>]</span><br><span class="line"><span class="string">'missing'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回结果表明__missing__()方法确实发挥了作用，但是key没有添加到字典当中去，我们再修改一下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self,key)</span>:</span></span><br><span class="line">self[key] = <span class="string">'wanglei'</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'wanglei'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd=defaultdict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'foo'</span>]</span><br><span class="line"><span class="string">'wanglei'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="string">'wanglei'</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="在旧的Python版本中实现defaultdict功能"><a href="#在旧的Python版本中实现defaultdict功能" class="headerlink" title="在旧的Python版本中实现defaultdict功能"></a>在旧的Python版本中实现defaultdict功能</h5><hr><p>本来这个我不想写了，但是我觉得有必要综合一下上面所说的。defaultdict类是在Python2.5中加入进来的，但是我们可以实现一个兼容defaultdict的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="comment"># 首先当 __getitem__()方法访问键失败的时候，调用__missing__方法。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,key)</span>:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">return</span> dict.__getitem__(self,key)</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line"><span class="keyword">return</span> self.__missing__(key)</span><br><span class="line"><span class="comment"># 实现__missing__方法来给设置默认值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(key)</span>:</span></span><br><span class="line">self[key] =value = self.default_factory()</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>然后defaultdict类的初始化函数__init__()需要接收类型或者可调用函数的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,default_factory=None,*a,**kwag)</span>:</span></span><br><span class="line">    dict.__init__(self,*a,**kwag)</span><br><span class="line">    self.default_factory = default_factory</span><br><span class="line">    <span class="comment"># 首先当 __getitem__()方法访问键失败的时候，调用__missing__方法。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,key)</span>:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">return</span> dict.__getitem__(self,key)</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line"><span class="keyword">return</span> self.__missing__(key)</span><br><span class="line"><span class="comment"># 实现__missing__方法来给设置默认值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(key)</span>:</span></span><br><span class="line">self[key] =value = self.default_factory()</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>本文主要参考了这篇</p><p><a href="http://kodango.com/understand-defaultdict-in-python" target="_blank" rel="noopener">http://kodango.com/understand-defaultdict-in-python</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python中，如果访问字典中不存在的键时会引发KeyError的异常。但是如果字典中的键如果能够有默认的值有时候是非常方便的。比如以下的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="Python学习" scheme="http://yoursite.com/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="defaultdict" scheme="http://yoursite.com/tags/defaultdict/"/>
    
  </entry>
  
  <entry>
    <title>如何提取出一首歌曲的梅尔频谱</title>
    <link href="http://yoursite.com/2019/02/18/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E5%87%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E6%9B%B2%E7%9A%84%E6%A2%85%E5%B0%94%E9%A2%91%E8%B0%B1/"/>
    <id>http://yoursite.com/2019/02/18/如何提取出一首歌曲的梅尔频谱/</id>
    <published>2019-02-18T12:17:26.000Z</published>
    <updated>2019-06-16T09:30:20.345Z</updated>
    
    <content type="html"><![CDATA[<p>1.声谱图</p><p>如下图1一段声音信号直观地看起来是时间和能量的关系，在语音识别，音乐信息检索中常常关注的是声音中频率和能量的关系，即声谱图描述的就是频率和能量的关系。所以我们拿到一段音频需要先进行初步的处理，获得它的声谱图。具体的做法则是将声音信号分帧，然后对每一帧都用短时傅里叶变换处理，当然进行傅里叶变换之前还预先需要对声音信号进行预加重，加窗。</p><p><img src="/images/声波图.jpg" alt></p><p>2.梅尔频谱</p><p>由于人耳对声音的感知不是线性的，人耳对声音的低频比对声音的高频更加敏感。所以常常需要将线性频谱转换到非线性的梅尔频谱。普通频率转换到梅尔频率的公式是</p><script type="math/tex; mode=display">m=2595log_{10}(1+\frac f{700})</script><p>我们将一组频域信号通过梅尔滤波器组就可以获得梅尔频谱。</p><p>总结一下获得梅尔频谱的大概流程：首先对时域信号进行傅里叶变换转换到频域，然后再利用梅尔频率刻度的滤波器组对应频域信号进行处理，就可以得到梅尔频谱。这个流程可以使用<a href="https://librosa.github.io/librosa/index.html" target="_blank" rel="noopener">librosa库</a>来完成，下面就是相应的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_melcepstrum</span><span class="params">(audio_path,mel_save_path)</span>:</span></span><br><span class="line">y, sr = librosa.load(aduio_path,sr=<span class="number">22050</span>) <span class="comment">#返回这首歌的time series序列和采样率</span></span><br><span class="line">S = librosa.core.stft(y,n_fft=<span class="number">1024</span>,hop_length=<span class="number">512</span>,win_length=<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># S.shape = (1+n_fft/2,帧数)</span></span><br><span class="line">X = np.abs(S)</span><br><span class="line">mel_basis = librosa.filters.mel(r,n_fft=<span class="number">1024</span>,n_mels=<span class="number">128</span>) <span class="comment">#梅尔滤波器矩阵</span></span><br><span class="line"><span class="comment"># mel_basis.shape=(n_mels,1+n_fft/2)</span></span><br><span class="line">mel_s = np.dot(mel_basis,X)</span><br><span class="line">np.save(mel_save_path,mel_s)</span><br></pre></td></tr></table></figure><p>reference</p><p>以下这两篇博客将<strong>梅尔频率倒谱系数(MFCC)讲得很清楚</strong>，推荐！求MFCC需要在梅尔频谱的基础上继续取对数再进行变换。这次我只是把梅尔频谱当做神经网络的输入，就先到这里。</p><ol><li><a href="https://blog.csdn.net/zouxy09/article/details/9156785" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/9156785</a></li><li><a href="https://blog.csdn.net/xmdxcsj/article/details/51228791" target="_blank" rel="noopener">https://blog.csdn.net/xmdxcsj/article/details/51228791</a></li><li>CMU的教程也不错：<a href="http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf" target="_blank" rel="noopener">http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.声谱图&lt;/p&gt;
&lt;p&gt;如下图1一段声音信号直观地看起来是时间和能量的关系，在语音识别，音乐信息检索中常常关注的是声音中频率和能量的关系，即声谱图描述的就是频率和能量的关系。所以我们拿到一段音频需要先进行初步的处理，获得它的声谱图。具体的做法则是将声音信号分帧，然后对每一
      
    
    </summary>
    
      <category term="音频信号处理" scheme="http://yoursite.com/categories/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
      <category term="梅尔频谱" scheme="http://yoursite.com/tags/%E6%A2%85%E5%B0%94%E9%A2%91%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>杨奕轩老师</title>
    <link href="http://yoursite.com/2019/01/12/%E6%9D%A8%E5%A5%95%E8%BD%A9%E8%80%81%E5%B8%88/"/>
    <id>http://yoursite.com/2019/01/12/杨奕轩老师/</id>
    <published>2019-01-12T14:39:10.000Z</published>
    <updated>2019-05-30T02:25:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/与杨奕轩老师的合影.jpg" alt></p><p>在2019年的一月七日，李老师在群里发了一条消息，杨奕轩老师会在一月十日途经上海，到时候会一起吃饭交流！我实在是没有想到能够这么快就见到杨老师，杨老师是台湾中央研究院的老师，他实验室的研究方向是音乐信息检索MIR，杨老师博士期间就开始做音乐情感计算，找到教职后又做了很多音乐情感的工作。</p><p>实验室其他同学可能不太了解杨老师的工作，但是我却再熟悉不过了。我读的第一篇音乐情感计算方面的论文就是杨老师博士期间2008年发在IEEE Transactions on audio，speech，and language processing杂志上的经典论文。这篇经典论文后来非常多次被引用。由于IEEE 杂志每篇论文后面都会有作者的头像和基本信息，杨老师放在那上面的照片是真的帅气，见面之前我猜测：“杨老师2008年应该28岁左右，现在十年过去了杨老师应该是38岁左右吧？”</p><p>一月十号上午十点多老师让我和江益靓师姐去张衡路大门接杨老师，并带杨老师到校园里面逛一逛。师姐不熟悉杨老师，我只和她说了杨老师十年前长得很帅气，但是现在是啥样我也不知道。等了一会儿杨老师就到了，一打开车租车的门，我就惊叹出：哇，还是那么的帅气。杨老师第一次来上海，第一次来复旦。</p><p>他简单的问了我和师姐的基本情况之后，我们直接带他到实验室放下东西。没想到他坐下来直接就和我们开始讨论起来，问我和另外两位师姐目前在做什么工作。他先和研三师姐交流，师姐是做语音增强的，她说杨老师实验室的在SISEC比赛上得到了第三名，杨老师笑着说是第二名，因为一二名得主都是Sony，而且他们现在有一个新的模型已经比Sony第一名的成绩更好，不过还没有发表。然后师姐和杨老师讨论起一些论文，并且杨老师直接推荐了一篇2019年的论文给师姐。紧接着他又问研二的江师姐做了什么工作，师姐和他说她主要在做根据人的嗓音来推荐可以唱的歌曲这个方向，杨老师说这个很有新意啊，接着师姐又说起她昨晚看到的一个医学诊断比赛，是台湾的大学举办的，但是她没有及时的关注到，她想要现在想要他们比赛的数据集。杨老师翻了翻比赛的网站，说其中一位举办者的办公室就在他的隔壁。</p><p>然后杨老师就开始问我我在干嘛，我有点紧张，毕竟杨奕轩老师是音乐情感领域非常厉害的大牛，突然要和大牛面对面交流了。我说起我在关注的2018年ISMIR上两篇关于迁移学习的文章，我说这两篇论文和17年ISMIR那篇最佳论文迁移学习很像，只不过17年那篇用的是“音乐标签”，这里我卡了以下，我没有很快想起“音乐标签”这几个关键词，没想到杨老师马上说：“对，一些music tag”。他肯迪看过这篇论文，我说那你知道这两篇论文吗，这也是韩国人做的工作，只不过18年的论文他们用airtist labels来训练。杨老师说：“他懂”。于是我接着说我接下来还会继续关注迁移学习在音乐情感上的应用。我问杨老师实验室目前在音乐情感方面做什么？他说他有和奥地利一个老师合作，思路也和刚才说的这个迁移学习的想法很像，就是建立一个很大的资料库，收集几十万首歌曲，结合ALLMusic来收集一些情感标签，但是这里面有很多noisy的标签，不管这些，做成一个很大的资料库，利用这个资料库来训练模型，一个可能的方向是在这个数据 库当中在筛选出一些高质量的情感标签出来，与此同时杨老师也提到他们实验室不再做这个方向了，因为这个方向太难做了。<strong>他又说到同样的模型，用来做流派分类也能work的很好，用来做情感分类也很work，从这一点上很受审稿人的刁难，审稿人更希望能够看到一些针对音乐情感本身的研究，一些有新意的研究。他也很意外去年那篇迁移学习的论文能够获得最佳论文，可能是他的论文和实验都做得很完整吧。要想继续在这上面做必须要更多的针对音乐情感本身出发，但是这是很难的</strong>。被杨老师这一席话说得我有点灰心，确实他作为音乐情感计算领域这么厉害的研究者，他都不看好。</p><p>后来吃饭的时候，李老师和杨老师聊了很多大陆有哪些做MIR的研究组，还有前年在苏州举办的ISMIR会议，也讨论了很多关于中国大陆的科研体制和台湾科研体制，也说了上海房价很高。也是在这时，我才知道杨老师只有34岁，他比我猜测的年龄小多了，这也意味着他十年前做出的那篇经典论文还是24岁。和杨老师交流的过程中我们能感觉到他目前还在科研一线，MIR领域的前沿他都follow了，这一点真是太厉害了。</p><p>他说：“他不管有多忙，每周一都会空出来和他实验室的同学group meeting，读论文”。</p><p>我说：“杨老师，那你一定要坚持下去”我之所以这么说是因为目前很多中国大陆的青年学者，在找到教职，或者有行政职务以后就慢慢的不做科研了。这种现象无疑是非常不好的。</p><p>他说：“在他有了孩子以后确实没有以前那么多精力在科研上了，而且现在他和他太太想要第二个孩子。”</p><p>吃饭的时候我还问杨老师知道台大的李宏毅老师吗？他说知道啊，我说在大陆这边很多学生都听过他的深度学习课，他的课讲得非常好，很受学生欢迎。杨老师打趣说:”李宏毅老师是台湾AI界的网红，他实验室很多学生如果不懂深度学习他也会让他们去看李宏毅老师的课。”虽然我可能见不到李宏毅老师了，但是我希望杨老师如果有机会见到李宏毅老师，或许他会提起大陆有很多学生喜欢他讲的课吧。</p><p>吃完饭，李老师让高薇师姐和江师姐送杨老师去徐汇区那边的酒店，我主动提出说我也要去。我不能错过能和杨老师交流的机会。</p><p>在车上，师姐问起：“杨老师参加工作多久了，他说他参加工作已经八年半了，在他博士毕业之后他还去当了一年兵。”令人惊叹！</p><p>后来我们又问起台湾博士毕业需要什么条件</p><p>他说：”只要一篇IEEE transactions就行，但是硕博连读只用了三年半，我远超毕业的要求，我有3篇IEEE transactions“  </p><p>我们：“…”</p><p>杨老师还和我们交流我们的题目是怎么选的，我们说都是老师替我们选的，之后他聊起了他们实验室的学生，他说他招生很严格，招的学生都基本上是要去国外读PHD的，所以学生都很有motivation，他们都掌握了很多的乐理，有个学生本科是学电子工程的，但是选修很多做作曲的课，所以这对研究很有帮助。他们实验室现在有五个学生在做算法作曲。</p><p>他说：“他觉得他对学生很好，junior的学生刚进来会先跟着senior的学生做，senior的学生的题目他会帮助制定，但是也要他们有兴趣做才行”</p><p>后来我们聊起了group meeting和idea，师姐问杨老师会不会给学生想idea，他说他的idea经常一提出来就被学生否定，因为学生都能想到更好的idea，不过这样他都很开心。<strong>他还说在他们的group meeting前他会要求学生先提交要说的东西，如果他觉得他的学生报告的主题知识介绍自己所做的方向，他会建议他的学生换一个报告主题。因为他觉得group meeting不是学生汇报给老师听，要汇报可以单独汇报，而是要学生相互交流，讨论一些有意思的idea。他并不需要学生和他来讲，因为学生讲的对于杨老师来说不是第一次听，而是早就听了好几次了。</strong></p><p>听到这么一说，我和两位师姐面面相觑，因为我们的组会好像就当成向老师报告，而且很多听的同学并不会参与到别人的报告当中。博士师姐说她之前的组会都做得不好，其实大家有何尝不是呢？<strong>听了杨老师这些，我们确实应该rethink我们的组会，因为我们在组会当中没有扮演好自己的角色</strong>。后来的我们还继续讨论一些学术，我们当中无一不深深的折服于杨老师的对整个研究领域的学术观点。</p><p>这篇博客我不能够完整地记录所有重要的对话，可能每个人都会记住自己认为重要的内容吧。从这次简短的交流可以看出：杨奕轩老师是一位MIR领域学术造诣很高的青年研究者，他也是一位管理有方的实验室负责人，他也非常的谦逊，平和。我不觉得他是一位谷歌学术引用已经3000多次的学术研究者，和他的交流过程让我觉得他像是一位博士师兄一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/与杨奕轩老师的合影.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在2019年的一月七日，李老师在群里发了一条消息，杨奕轩老师会在一月十日途经上海，到时候会一起吃饭交流！我实在是没有想到能够这么快就见到杨老师，杨老师是台湾中央研究院的老师，他实验室的
      
    
    </summary>
    
      <category term="科研生活" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="学术交流" scheme="http://yoursite.com/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>2018年度回顾</title>
    <link href="http://yoursite.com/2018/12/30/2018%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2018/12/30/2018年度回顾/</id>
    <published>2018-12-30T11:17:15.000Z</published>
    <updated>2019-05-30T02:23:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>忙里偷闲，决定在一年的倒数第二天回顾下自己的2018年。</p><p>本着现代人不喜欢看太长的文字，太长的视频。我决定用自问自答的方式完成这篇年度总结。</p><p>Q代表我向自己提问，A代表我回答自己的提问。</p><ol><li><p>Q：2018年是你人生进程中相当重要的一年，有哪些新的变化和感受？</p><p>A：这一年里我结束了写满失望的本科生涯，离开了生活了22年的湖南，来到了一直想来的上海，到fdu继续自己的学生生涯。在后半年熬夜的天数暴增。同样在这一年我终于萌生出对计算机的喜爱，严格来说这一年开始写下第一行程序，想要学习一些新奇的计算机技术。离开了家乡才知道原来自己的普通话是多么的糟糕！这一年终于开始写博客，在未来会继续维护两个博客。</p></li><li><p>Q：2018年最有价值的一个选择？</p><p>A：很早就揣着要环游世界的想法，然而那只是一个想法，从来没有认真的实现它过。所以今年的最佳选择是2018年九月收到复旦大学登山协会一条关于穿越炉西峡的推送，我只用了几分钟考虑就决定参加。这是一个美好又意义深远开始，后来我还和华师大萤火虫去了温州雁荡山，寒假里我还要去宝岛台湾完成环岛活动。或许那一晚会是我完成环游世界梦想的开端。</p></li><li><p>Q：2018年最遗憾的一件事？</p><p>A：和一个认识多年的朋友闹掰了，近一年没有说过话了。我犯过的错误很多，这是其中一个。</p></li><li><p>Q：2018年看过的最佳电影？</p><p>A：从我全年线下和线上看过的四十多部各种题材的电影候选里。《爱在黎明破晓时》《爱在日落黄昏时》是我心中的最佳电影。电影里对爱情和性的谈论真是impressive，我觉得没有谈过恋爱的人恋爱必看，还没有结婚的结婚前必看，啊，已经结婚了？还是必看。</p></li><li><p>Q：2018年玩过的最佳游戏？</p><p>A：今年花了不少钱在购买游戏，游戏设备上。手上目前屯了(八方旅人，黑暗之魂)没玩，真正完整玩完了的游戏只有《塞尔达传说·旷野之息》，《返校》，《死亡细胞》，恕我实在是没有时间玩游戏。毫无疑问，《旷野之息》是我心中最佳游戏，在我做本科毕设的时候我花了大概85小时在旷野之息上。谁知道这是我时间最富裕的一段时间了，后来我就再也没有充足时间，能够全身心地去鉴赏一款游戏了。在我心中具有优秀设计的游戏就像艺术品一样。</p></li><li><p>Q：2018年看过的最佳书籍？</p><p>A：说来惭愧，这应该是我做得最不好的事情了。在阅读方面，读的书籍实在是太少太少了。如果愣是要少中选优的话是《创新公司皮克斯的启示》。理由是：它讲了一家公司为什么能成为一家创新公司，虽然我没有公司，不过我从里面学到如何和聪明人相处？今年在阅读方面我简直就是个loser，然而我在知乎上却读了6600万字，阅读的时间都去哪了？呵呵，花在知乎上了。真是少刷知乎多读书的反面典型。</p></li><li><p>Q：明白的最深刻的一个道理？</p><p>A：很多事情，我们只能看到表面，表面上看起来很酷，实际上真正做起来很难。就像人工智能看起来很酷，真正从事起来发现这是一堆数学，这个工作一点都不酷；就像我们玩到一个优秀游戏后，心里自然而然就有一种冲动，我为什么不能成为一个游戏设计者，然而当看到游戏开发背后的故事时，会发现游戏开发那一点都不酷，相当的无聊。</p></li><li><p>Q：新年有什么愿望？</p><p>A：希望父母身体健康，希望新的一年里自己的英语听说读写水平有好的进步。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忙里偷闲，决定在一年的倒数第二天回顾下自己的2018年。&lt;/p&gt;
&lt;p&gt;本着现代人不喜欢看太长的文字，太长的视频。我决定用自问自答的方式完成这篇年度总结。&lt;/p&gt;
&lt;p&gt;Q代表我向自己提问，A代表我回答自己的提问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Q：2018年是你人生进程
      
    
    </summary>
    
      <category term="人生之旅" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="年度总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>近窥MIREX-Like数据集和MIREX 08数据集</title>
    <link href="http://yoursite.com/2018/12/26/%E8%BF%91%E7%AA%A5MIREX-Like%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8CMIREX%2008%20%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/26/近窥MIREX-Like数据集和MIREX 08 数据集/</id>
    <published>2018-12-26T12:04:53.000Z</published>
    <updated>2019-03-19T02:42:38.096Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章翻译自<a href="https://musicinformationretrieval.wordpress.com/2017/03/16/take-a-closure-look-at-the-dataset/" target="_blank" rel="noopener">Student blog for the MIR course, Master in Sound and Music Computing, Universitat Pompeu Fabra (2017)</a>。我觉得还挺有意思的就翻译了一下，有些我拿不准的地方我就引用了原文的词语。这两个数据集还挺有意思。</p><hr><p>MIREX-Like数据集第一次在10th International Symposium on Computer Music Multidisciplinary Research-CMMR‘2013会议上公布出来[1]，由于一直缺乏标准的，标注质量好的音乐情感数据集，研究者们在绝大部分音乐情感学术研究里都使用自己制作的数据集，这导致他们取得的结果不能够在同一个数据集上进行比较。尽管每年MIREX 情感识别竞赛有mirex mood classification数据集，但是这个数据集不是公开的。新的MIREX-Like数据集 包含了903首音乐样本，同样这也是一个用于音乐情感研究的多模态数据集，它还囊括了歌词和每首歌的MIDI，但是它只有196首歌曲的MIDI。</p><ul><li><strong>数据集的获取</strong></li></ul><p>MIREX-Like数据集的制作者从ALLMusic收集数据，ALLMusic上的音乐标注都是由专业人员标注，而不是Last.FM的数据都是由音乐社区中的音乐听众标注的。所以ALLMusic的标注可能更加可靠。制作者收集标注时使用的情感标签和MIREX 08数据集是一致的。如果某首音乐的标签属于多个类别，那么他们会偏向选择标签数量更多的情感类别。比如：一首歌有’passionate‘(Cluster1)，‘confident’(Cluster1),’humorous‘(Cluster4)，那么这首歌会被分类到Cluster1。MIREX-Like数据集总共903首音乐歌曲，在五个类别上的数量分布是很平衡的，其中18.8%cluster 1, 18.2% cluster 2, 23.8% cluster 3, 21.2% cluster 4 and 18.1% cluster 5。</p><ul><li><strong>数据特征</strong></li></ul><p>即便标签都是由专业人员标注，这些标签在五个类别的的划分仍然不是很合理。尽管我们不能直接比较两个数据集，因为我们没有办法听到MIREX 08数据集的音乐文件。通过一个简单的验证步骤，我们能够得到结论：MIREX-Like数据集的歧义性(原文用的是ambiguity)比MIREX 08高。</p><p>的确，拿我们论文[2]当中用过的特征，使用SVM在MIREX-Like数据集分类，accuracy只有区区的40%，相比MIREX 08上的大多数结果在60%左右，这是一个很低的结果。MIREX-Like数据集的作者也在该文章[1]中使用了他们的分类方法，用SVM分类也只有44.9%的分类准确率。然而，他们使用一些旋律相关特征时，准确率可以提高到52.8%。他们基于旋律自动提取系统提取的98个旋律相关特征，尽管这些特征的用途并不相同。</p><ul><li><strong>类别分析</strong></li></ul><p>就在语义空间表示而言，用来讨论分析情感分类方法使用的不同情感分类类别是非常重要的，因为它或许能够解释这些分类算法的混乱。文献[4]分析了不同情感空间表示的intra-cluster similarity(类内相似性)和inter-cluster similarity(类间相似性)。intra-cluster similarity衡量的是<strong>community-based表征和expert-based表征(如Russell情感表示[5])之间的一致性</strong></p><p>就MIREX使用的五类情感类别而言，具有最低intra-cluster similarity的是cluster2(sweet, good natured,cheerful, rollicking, amiable, fun)，也许这么普通大众和专家意见如此一致的原因是这一类都是一些使人快乐的音乐。然而如果使用的形容词如果不是如此普通寻常的词语的话，这样做也许会降低这个值。总之MIREX 的情感表示的intra-cluster similarity相当高。</p><p>inter-cluster similarity，它在音乐情感分类方法中非常重要，衡量的是不同的情感类别之间的独立性(原文用的how separable the cluster are)，它的计算方法是取一个类别质心(类别内所有点的平均值)到其他所有类别质心之间的余弦距离，文献[4]给出了MIREX clusters类别的inter-cluster similarity混淆矩阵(confusion matrix)。这个矩阵告诉我们，cluster1和cluster5的值最低，表示这两个情感类别相当相似。</p><p>这些发现和MIREX竞赛上的结果是一致的，这两类的混淆性也很显著(见文献[6]），文献6也给出了cluster2和cluster4的混淆性(confusion)。</p><p>此外观察到的最独立的cluster5和cluster2，在MIREX 分类结果上也具有比较小的混淆性(confusion)[4]。</p><p><img src="images/Mirex-like数据集的插图.jpg" alt></p><p>Laurier表示MIREX的情感类别表示，还有在他研究里的其他情感表示既有优点但是也有局限性，观察到的不同MIREX cluster之间的混淆性和相似性验证了先前分析的结果。</p><p>从Lauriers分析中的计算结果来看，他认为MIREX的情感表示目前不是一个最优的表示方法。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] R. Panda, R. Malheiro, B. Rocha, A. Oliveira, and R. P. Paiva, “Multi-Modal Music Emotion Recognition: A New Dataset, Methodology and Comparative Analysis” 10th International Symposium on Computer Music Multidisciplinary Research – CMMR’2013.</p><p>[2] Laurier, Cyril, et al. “Audio music mood classification using support vector machine.” <em>MIREX task on Audio Mood Classification</em> (2007): 2-4.</p><p>[3] Salamon, Justin, Bruno Rocha, and Emilia Gómez. “Musical genre classification using melody features extracted from polyphonic music signals.” <em>Acoustics, Speech and Signal Processing (ICASSP), 2012 IEEE International Conference on</em>. IEEE, 2012.</p><p>[4] Laurier, Cyril. <em>Automatic classification of musical mood by content based analysis</em>. Universitat Pompeu Fabra, 2011.</p><p>[5] Ressel, J. A. “A circumplex model of affect.” <em>J. Personality and Social Psychology</em> 39 (1980): 1161-78.</p><p>[6] Downie, X. H. J. S., Cyril Laurier, and M. B. A. F. Ehmann. “The 2007 MIREX audio mood classification task: Lessons learned.” <em>Proc. 9th Int. Conf. Music Inf. Retrieval</em>. 2008.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://musicinformationretrieval.wordpress.com/2017/03/16/take-a-closure-look-at-the-dataset/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Dataset" scheme="http://yoursite.com/categories/Dataset/"/>
    
    
      <category term="Music Emotion Rearch" scheme="http://yoursite.com/tags/Music-Emotion-Rearch/"/>
    
      <category term="文章翻译" scheme="http://yoursite.com/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
