<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王磊的百草园</title>
  
  <subtitle>Life Is Short</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-24T11:19:00.477Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wanglei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/05/09/Recommending%20music%20on%20Spotify%20with%20deep%20learning/"/>
    <id>http://yoursite.com/2019/05/09/Recommending music on Spotify with deep learning/</id>
    <published>2019-05-09T05:51:19.101Z</published>
    <updated>2019-05-24T11:19:00.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Recommending-music-on-Spotify-with-deep-learning"><a href="#Recommending-music-on-Spotify-with-deep-learning" class="headerlink" title="Recommending music on Spotify with deep learning"></a>Recommending music on Spotify with deep learning</h2><p>August 05, 2014</p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>今年夏天，我在纽约Spotify实习，我的实习工作是使用卷积神经网络基于音乐内容做音乐推荐，在这篇博客中，我会解释我的方法和展示一些初步的结果。</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>这篇博客很长，这里提供一个博客各个部分的一些概览。如果你想跳过一些部分，直接在下面选择章节标题就可以到达。</p><ul><li><p><a href="#1">协同过滤</a></p><p>非常简单的介绍一下协同过滤的优缺点</p></li><li><p><a href="#2">基于内容的推荐</a></p><p>当没有可用的数据时该如何做？</p></li><li><p><a href="#3">使用深度学习来预测用户的偏好</a></p><p>基于音乐音频信号的音乐推荐</p></li><li><p><a href="#3">拓展部分</a></p><p> 我在Spotify训练的网络细节</p></li><li><p><a href="#5">分析：卷积神经网络学到了什么？</a></p><p>当使用很多音乐音频样本来训练卷积神经网络时，它学到了什么有关于音乐的东西？</p></li><li><p>这项研究能够用来做什么？</p><p>潜在的应用</p></li><li><p>未来工作</p></li><li><p>总结</p></li></ul><h3 id="1">Collaborative filtering</h3><p>Spotify传统的音乐推荐非常依赖于协同过滤算法来提升推荐准确度。协同过滤的主要思想是从用户的历史行为数据决定用户的偏好。比如说，如果两个用户听了大量相同的歌曲，那么这两位用户的音乐品味可能是相似的，如果两首歌被相同的用户群体听过，那么这两首歌听起来也是相似的。这种信息能够用来做推荐</p><p>纯粹的协同过滤方法不适用任何和被推荐物品<strong>内容</strong>有关的信息，只使用和被推荐物品有关的消费行为信息，换句话说，这些信息是与被推荐物品内容无关的。这使得这种方法能够被广泛使用：同样的模型能够被用来推荐书，电影，音乐等。</p><p>不幸的是，这种方法也被证明有很大的缺陷。由于这种方法非常依赖于用户的行为数据，越流行的物品比不那么流行的物品会被更加容易被推荐，因为对于流行的物品来说，有更多的可用的用户行为数据。这个问题通常不是我们想遇到的。同样出于这个原因，推荐的物品可能让用户觉得无聊和重复的。</p><p>这种方法存在另外一个问题在因为推荐上尤为明显。那就是有着相似用户行为的物品往往内容却非常不相同(the heterogeneity of content with similar usage patterns)。比如说，用户可能一次收听一整张专辑，但是一张专辑也许包括intro tracks，outro tracks，interludes，cover songs，remixes。</p><p>但是最大的问题是新的和不流行的歌曲不能够被推荐，如果没有可用的用户行为数据分析，那么协同过滤算法就会失效。这也就是所谓的冷启动问题(cold-start problem ). 我们想要能够推荐刚刚发布的音乐作品，我们想要给用户推荐他们不知道的非常棒的乐队，想要完成这个目标，我们需要用不同的方法！</p><h3 id="2">Content-based recommendation</h3><p>最近，Spotify饶有兴趣地想要整合其他信息源进入他们的推荐系统当中达缓解一些上述问题。这也也被Spotify几个月前收购了音乐智能平台The Echo Nest所证明，有非常多不同种类和音乐相关的信息可以被推荐系统利用：tags，歌手和专辑信息，歌词，从web端挖掘的文本信息，甚至是音频信号本身。</p><p>对于以上的所有信息，大概音频信号本身是最难有效使用的，一方面music audio之间有巨大的语义鸿沟，另一方面，音乐的不同方面都会影响用户的偏好。一些信息能够很容易从音频信号中提取出来，比方说音乐的流派和所使用的乐器。其它的就有点困难，比如说音乐的情感，发行的年份，还有一些是不可能从音频本身提取出来的，比如说歌手的地理位置和歌词主题。</p><p>抛开以上这些难点，很明显的是歌曲本身很大程度上会决定用户是否喜欢听这首歌，所以通过分析音频信号来预测一首歌是否会被喜欢是一个很好的idea。</p><h3 id="3">predicting listening preference with deep learning</h3><p>在去年12月，我的同事Aaron van den Oord 和我在NIPS 2013上发了一篇这个主题的文章，名字就是”Deep content-based music recommendation”. 我们想要从音频信号本身来预测用户偏好，通过训练一个回归模型来预测一个之前使用协同过滤算法计算的潜在表征。这种方法能够让我们即使没有用户行为数据，也能够在协同过滤空间里面预测一个表征。你能够从我们的论文题目中推断出来了，这个回归模型就是一个深度神经网络。</p><p>这种方法的根本思想就是许多协同过滤模型把用户和歌曲都投影到一个共同的低维潜在空间。这首歌在这个空间里的位置由各种各样能够影响用户偏好的的信息编码。如果两首歌在这个空间里靠得很近，那么他们大概率是相似的，如果一首歌很靠近一个用户，那么这首歌对这个用户可能是一个很好的推荐(假如他们从来没有听过)。如果我们能够从音频来预测这首歌曲在这个空间里的位置，那么就能在没有用户行为数据的情况下将歌曲推荐给正确的用户。</p><p>在论文中我们使用t-SNE算法将模型预测的表征投影到低维空间。下面你可以看到结果图，相似的歌曲聚集在一起。Rap music 大部分能够在图的左上角找到，电音歌手则聚集在图的底部。</p><p><img src="/Users/wanglei/Pictures/representation_cnn_project.png" alt></p><h3 id="4">Scaling up</h3><p>论文中深度神经网络包括两层卷积层和两层全连接层，网络的输入时三秒的音频的频谱，为了获得更长音频的表征，我们将音频加上一个三秒的窗，取这些窗的平均的预测表征。</p><p>在Spotify，我能够接触到更大数据集，一堆不同协同过滤算法计算出来得laten factor representations，他们也给了我一个很好的GPU来训练模型，这能够使得我拓展之前的工作，现在我能够训练有七层或者八层的卷积神经网络，使用大得多的中间表征和更多的参数(应该是指更复杂的卷积层)。</p><h5 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h5><p>下面我会详细介绍尝试过的一个网络结构，它有四个卷积层和三个全连接层。正如你会看到的，用于音频信号的卷积神经网络和传统的应用于计算机视觉任务的网络有一些重要的不同。</p><p><img src="/Users/wanglei/Pictures/spotify_convnet.png" alt></p><p>这个网络的输入时599帧长和128个mel bins的梅尔频谱，梅尔频谱是一种时频域上的表征，在音频信号上用重叠的窗口做短时傅里叶变换，每一个傅里叶变换产生一帧，然后把这些帧concatenate成一个矩阵就构成了一张频谱，最后对这张频谱转换成梅尔频谱减少维度，幅度上也发生了对数转换。</p><p>卷积层上红色矩形就是卷积核在它们的输入上滑动，使用rectified linear units(ReLU，max(0，x))。注意所有层都是一维卷积，这种卷积只在时间维度上进行卷积，而不是在频域上卷积。尽管在频谱上的时域和频域两个维度上卷积在方法上是可行的，当前我不会这么做。因为频谱上的两个维度有不同的含义，这和图片的例子不同。因此使用经常用在图片上的二维卷积核这是不合理的。</p><p>在卷积层之间使用max-pooing对中间层的表征downsample，为他们增加一些时间不变性，在图中用<strong>MP</strong>标记。我在每一个卷积层上使用4帧大小的的卷积核，出于performance的原因，我在第一二个卷积层之间使用4大小的max-pooling，其它层之间都使用2大小的池化。</p><p>在最后一层卷积层后，我在时间维度上使用全局池化层，这一层能覆盖到整个时间轴，有效地计算在时域上学到的特征，我一共使用了三个池化函数：平均池化，最大值池化，L2正则。</p><p>我这么做的原因是在音频信号中检测到特征的绝对位置和眼前的任务尤其不相关。这和图片分类不同，在一张图片中，知道一个被检测到特定特征的大概位置是有用的，比如说，一个判断云的特征更可能在一张图片的顶端被激活，如果它在图片的底部被激活，也许它是检测到了一只羊。对于音乐推荐来说，我们只对音乐中一些特征整体上出现了还是没有出现感兴趣，所以在时域上做全局池化是非常合理的。</p><p>另外一个解决这个问题的方法是像我们NIPS那篇文章一样，在短的音频片段上训练一个神经网络，然后在更长的音频片段上加窗，将每一个窗口的值平均作为特征。然而，将池化整合到网络模型中似乎是一个更好的idea，因为在训练的时候，每一步池化都能够发生。</p><p>这个全局的池化特征然后作为一组带relu激活函数全连接层的输入，在这个网络中，网络的最后一层是作为输出层，用来预测40个由vector_exp算法计算的潜在因子，这个算法是曾经在Spotify所用到的众多协同过滤算法之一。</p><h4 id="training"><a href="#training" class="headerlink" title="training"></a>training</h4><p>训练网络优化的是从协同过滤算法得出潜在因子表征和我们网络从音频信号预测的表征之间的mean square error(MSE)，这些从协同过滤算法得到的表征做了归一化处理，这么做可以减少歌曲流行度的影响(对于很多协同过滤算法模型计算得到的表征往往和歌曲流行度有关)。Dropout在全连接层后用来正则化。</p><p>当前我用的数据集是从100万首流行音乐中间提取的30秒片段，计算出梅尔频谱，我大概用了这数据集的一半(50万)来训练，5000首用来验证，剩下的用来做测试集。在训练的时候，我们使用随机偏移值对频谱进行了修剪达到数据增强的目的。</p><p>这个神经网络使用Theano来搭建，在英伟达GTX 780Ti上使用mini batch梯度下降来优化loss，训练数据加载和数据增强分开实施，也就是说GPU在训练一个batch数据时，下一个batch的数据也在并行加载，总共进行了大约750000次梯度更新。我不记得整个网络大约花了多久训练，所有的步骤大概花了18-36小时</p><h4 id="Variations"><a href="#Variations" class="headerlink" title="Variations"></a>Variations</h4><p>正如我前面提到的，这只是我尝试过的其中一个网络结构，我还尝试了一些别的方法。</p><ul><li>更多层</li><li>使用maxout units作为激活函数，而不是用relu</li><li>使用随机池化而不是最大值池化</li><li>将L2正则整合到网络的输出层</li><li>数据增强在时域上使用了拉伸或者压缩频谱</li><li>将不同协同过滤算法得到的不同表征concatenate了</li></ul><p>还有一些方法没有达到我的预期</p><ul><li>从卷积层增加’bypass‘连接到全连接层，（我觉得这有点像resNet的思想，考虑到这还是14年，作者就已经很超前了），当然作者这里这么做的motivation是他认为底层特征也能够对音乐推荐有作用，但是不幸的是，这种设置非常阻碍训练(可能还是当时的计算能力有限)</li><li>想mixture density networks一样预测一个表征的条件方差，然后获得一个对预测表征的置信估计，确定哪首歌的潜在因子表征是困难的。然而这会使得训练非常的困难，并且结果的置信度估计不如预期表现得好。</li></ul><h3 id="5">Analysis：what is it learning?</h3><p><strong>接下来就是本篇博客的spotlight部分了，打起精神！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Recommending-music-on-Spotify-with-deep-learning&quot;&gt;&lt;a href=&quot;#Recommending-music-on-Spotify-with-deep-learning&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh远程登录linux出错解决办法</title>
    <link href="http://yoursite.com/2019/04/02/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95linux%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/02/ssh远程登录linux出错解决办法/</id>
    <published>2019-04-02T03:36:47.000Z</published>
    <updated>2019-04-02T03:39:45.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="用ssh远程登录linux出错解决办法"><a href="#用ssh远程登录linux出错解决办法" class="headerlink" title="用ssh远程登录linux出错解决办法"></a>用ssh远程登录linux出错解决办法</h4><h4 id="1-报错情况"><a href="#1-报错情况" class="headerlink" title="1.报错情况"></a>1.报错情况</h4><blockquote><p>ssh：connect to “my host” port22:Connection refused</p></blockquote><p>从服务器端想要传输文件回本地端时，首先出现这个问题，</p><p>最开始尝试的解决办法是我没有装openssh-server</p><p>于是我用了以下两条命令</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo apt-get purge openssh-server </span><br><span class="line">&gt; sudo apt-get install openssh-server</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后… 就变成了这个报错</p><blockquote><p>mirlab@mirlab-fdu:~/wanglei/fma_dataset$ scp -r /home/mirlab/wanglei/fma_dataset/saved_model <a href="mailto:mer@10.141.247.205" target="_blank" rel="noopener">mer@10.141.247.205</a>:/home/wanglei/PycharmProjects/fma_dataset<br><a href="mailto:mer@10.141.247.205" target="_blank" rel="noopener">mer@10.141.247.205</a>‘s password:<br>Permission denied, please try again.<br><a href="mailto:mer@10.141.247.205" target="_blank" rel="noopener">mer@10.141.247.205</a>‘s password:<br>Permission denied, please try again.<br><a href="mailto:mer@10.141.247.205" target="_blank" rel="noopener">mer@10.141.247.205</a>‘s password:<br>Permission denied (publickey,password).<br>lost connection</p></blockquote><p>查到原因说是我的sshd-config中没有允许root 用户登录。于是我又打开了/etc/ssh/sshd_config</p><blockquote><p>sudo vi /etc/ssh/sshd_config</p></blockquote><p>将其中的PermitRootLogin设置成了yes</p><blockquote><p>PermitRootLogin yes</p></blockquote><p>还是出现了一样的问题，然后我又继续找，找到一个办法就是在/etc/ssh/sshd_config中加一个设置</p><blockquote><p>AllowUsers  yourusername</p></blockquote><p>这一行命令允许你的服务器连接到username为你上面设置的yourusername，其他的用户会被拒绝。</p><p>别忘了重启ssh服务</p><blockquote><p>service sshd restart</p></blockquote><p>最后在终端打上这行命令即可发现你可以使用ssh连接远程的服务器端了,大功告成了!</p><blockquote><p>ssh yourusername@yourhostname </p></blockquote><h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h4><p>总的来说，我们需要在本地sshd_config中把你想要用的username 加入到AllowUsers中。</p><p>具体流程</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo vi /etc/ssh/sshd_config</span><br><span class="line">&gt; PermitRootLogin yes</span><br><span class="line">&gt; AllowUsers otheruser</span><br><span class="line">&gt; service sshd restart</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;用ssh远程登录linux出错解决办法&quot;&gt;&lt;a href=&quot;#用ssh远程登录linux出错解决办法&quot; class=&quot;headerlink&quot; title=&quot;用ssh远程登录linux出错解决办法&quot;&gt;&lt;/a&gt;用ssh远程登录linux出错解决办法&lt;/h4&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="Linux系统" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux系统" scheme="http://yoursite.com/tags/Linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2019电影盘点</title>
    <link href="http://yoursite.com/2019/04/02/2019%E7%94%B5%E5%BD%B1%E7%9B%98%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/02/2019电影盘点/</id>
    <published>2019-04-02T03:36:06.000Z</published>
    <updated>2019-04-02T03:41:33.436Z</updated>
    
    <content type="html"><![CDATA[<p>人生短暂，看电影也要慎重啊。</p><p>1.流浪地球</p><p>非常好的国产科幻电影，好就好在脑洞的设定，还有就是剧情，演员都基本在线。</p><p>2.飞驰人生</p><p>爆米花电影</p><p>3.阿丽塔战斗天使</p><p>这个是世界的设定很有意思，废铁城和撒冷，在注定废铁城的人们要登上撒冷，毁掉撒冷，就像饥饿游戏的设定一样。</p><p>4.绿皮书</p><p>这部电影处处彰显温情，主题又非常鲜明。是今年不可多得的佳作</p><p>剧中的台词非常考究，能让人醍醐灌顶。</p><p>经典台词：”the world full of lonely people afraid to make the first move!”</p><p>还有托尼说过的：”不管你做什么，都要做到极致，上班就认真工作，笑就尽情大笑，吃东西时就像是最后一餐那样去享受。”</p><p>5.华盛顿邮报</p><p>这部电影基于美国1971年”五角大楼文件泄密案”，剧中的两个主角，一个是华盛顿邮报的主编（汤姆汉克斯），一个是华盛顿邮报的老板(梅丽尔斯特里普)。顶住来自政府，银行，同行施加的压力，毅然决然要向公众披露美国政府卷入越南战争的机密文件。这部电影彰显了美国的价值观，那就是出版自由，新闻自由，“free the press”的口号也在剧中出现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生短暂，看电影也要慎重啊。&lt;/p&gt;
&lt;p&gt;1.流浪地球&lt;/p&gt;
&lt;p&gt;非常好的国产科幻电影，好就好在脑洞的设定，还有就是剧情，演员都基本在线。&lt;/p&gt;
&lt;p&gt;2.飞驰人生&lt;/p&gt;
&lt;p&gt;爆米花电影&lt;/p&gt;
&lt;p&gt;3.阿丽塔战斗天使&lt;/p&gt;
&lt;p&gt;这个是世界的设定很有意思，
      
    
    </summary>
    
      <category term="生活一隅" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%80%E9%9A%85/"/>
    
    
      <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>pytorch中如何加载训练数据</title>
    <link href="http://yoursite.com/2019/03/29/pytorch%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2019/03/29/pytorch中如何加载训练数据/</id>
    <published>2019-03-29T14:01:57.000Z</published>
    <updated>2019-05-24T11:11:07.309Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-为什么不需要自己写加载方法"><a href="#1-为什么不需要自己写加载方法" class="headerlink" title="1.为什么不需要自己写加载方法"></a>1.为什么不需要自己写加载方法</h4><p>pytorch中提供了两个类用于训练数据的加载，分别是 torch.utils.data.Dataset和 torch.utils.data.DataLoader 。不像torchvision中集合了很多常用的计算机视觉的常用数据集，作为在音乐信息检索这方面，数据集要自己设计加载方法。如果每次不同的数据集都要自己写函数加载，</p><ul><li>每次读取代码不能够重用，不同的数据读取代码不同</li><li>自己写的加载函数也会有各种问题，比如说限制数据读取速度，或者当数据集太大，直接加载到字典或者列表中会很占用内存，数据读取阶段也会占用大量时间</li><li>只能单线程读取数据</li></ul><p>这次我做的实验需要加载歌曲的梅尔频谱，每个歌曲的片段为30秒，大约是一个1290*128大小的矩阵。所以这次我决定使用pytorch的Dataset类来加载数据。</p><h4 id="2-Dataset类"><a href="#2-Dataset类" class="headerlink" title="2.Dataset类"></a>2.Dataset类</h4><blockquote><p>class torch.utils.data.Dataset</p></blockquote><p>这个抽象类代表了数据集，任何我们自己设计的数据集类都应该是这个类的子类，继承这个类，重写 __len__() 方法，这个方法是用来获得数据集的大小，和__getitem__()方法，这个方法用来返回数据集中索引值为0到len(dataset)的元素。</p><ul><li>def __getitem__(self, index): 实现这个函数，就可以通过索引值来返回训练样本数据</li><li>def __len__(self): 实现这个函数，返回数据集的大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Dataset(object):</span><br><span class="line">    &quot;&quot;&quot;An abstract class representing a Dataset.</span><br><span class="line"></span><br><span class="line">    All other datasets should subclass it. All subclasses should override</span><br><span class="line">    ``__len__``, that provides the size of the dataset, and ``__getitem__``,</span><br><span class="line">    supporting integer indexing in range from 0 to len(self) exclusive.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def __add__(self, other):</span><br><span class="line">        return ConcatDataset([self, other])</span><br></pre></td></tr></table></figure><p>如果不重写这两个私有函数，就会触发错误。</p><h4 id="3-定义自己的数据集类"><a href="#3-定义自己的数据集类" class="headerlink" title="3.定义自己的数据集类"></a>3.定义自己的数据集类</h4><p>于是我就针对自己的需求实现了以下的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Fma_dataset(Dataset):</span><br><span class="line">    # root 是训练集的根目录， mode可选的参数是train，test，validation，分别读取相应的文件夹</span><br><span class="line">    def __init__(self, root, mode): </span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.root = root + &quot;/fma_&quot; + self.mode</span><br><span class="line">        self.mel_cepstrum_path = self.get_sample(self.root)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        sample = np.load(self.mel_cepstrum_path[index])</span><br><span class="line">        data = torch.from_numpy(sample[0])</span><br><span class="line">        target = torch.from_numpy(sample[1].astype(np.float32))</span><br><span class="line">        return data, target</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        if self.mode == &quot;train&quot;:</span><br><span class="line">            return 23733  # 训练集大小</span><br><span class="line">        elif self.mode == &quot;validation&quot;:</span><br><span class="line">            return 6780  # 验证集大小</span><br><span class="line">        elif self.mode == &quot;test&quot;:</span><br><span class="line">            return 3390  # 测试集大小</span><br><span class="line"></span><br><span class="line">    def get_sample(self, root):</span><br><span class="line">        cepstrum = []</span><br><span class="line">        for entry in os.scandir(root):</span><br><span class="line">            if entry.is_file():</span><br><span class="line">                cepstrum.append(entry.path)</span><br><span class="line">        return cepstrum</span><br></pre></td></tr></table></figure><h4 id="4-DataLoader类"><a href="#4-DataLoader类" class="headerlink" title="4.DataLoader类"></a>4.DataLoader类</h4><blockquote><p><em>class</em><code>torch.utils.data.DataLoader</code><strong>(</strong>dataset<strong>,</strong> <em>batch_size=1**</em>,<strong> <em>shuffle=False</em></strong>,<strong> <em>sampler=None</em></strong>,<strong> <em>batch_sampler=None</em></strong>,<strong> <em>num_workers=0</em></strong>,<strong> <em>collate_fn=<function default_collate></function></em></strong>,<strong> <em>pin_memory=False</em></strong>,<strong> <em>drop_last=False</em></strong>,<strong> <em>timeout=0</em></strong>,<strong> <em>worker_init_fn=None</em></strong>)**</p></blockquote><p>仅仅有通过索引返回训练数据数不够的，我们还需要DataLoad类提供拓展功能。</p><ul><li>可以分批次读取：batch-size</li><li>可以对数据进行shuffle操作</li><li>可以用多个线程来读取数据</li></ul><p>这个类我们不需要实现代码，直接调用，设置好参数就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-为什么不需要自己写加载方法&quot;&gt;&lt;a href=&quot;#1-为什么不需要自己写加载方法&quot; class=&quot;headerlink&quot; title=&quot;1.为什么不需要自己写加载方法&quot;&gt;&lt;/a&gt;1.为什么不需要自己写加载方法&lt;/h4&gt;&lt;p&gt;pytorch中提供了两个类用于训练
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题之路(六)</title>
    <link href="http://yoursite.com/2019/03/24/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF-%E5%85%AD/"/>
    <id>http://yoursite.com/2019/03/24/Leetcode刷题之路-六/</id>
    <published>2019-03-24T12:36:54.000Z</published>
    <updated>2019-03-24T12:38:15.304Z</updated>
    
    <content type="html"><![CDATA[<p>这五道题全部都是和树的遍历有关系，也是非递归的二叉树遍历写法，有前中后序三种遍历，按层遍历。总结如下。</p><h5 id="LeetCode94二叉树的中序遍历"><a href="#LeetCode94二叉树的中序遍历" class="headerlink" title="LeetCode94二叉树的中序遍历"></a>LeetCode94二叉树的中序遍历</h5><p>算法思路：二叉树的前序遍历和中序遍历代码基本一致，不同的地方在于什么时候该访问父节点。非递归的写法主要是使用一个栈来保存已经访问过的结点，其实树的前中后序三种遍历就是深度优先搜索的变形。</p><p>具体的来说，中序遍历一直将访问到的结点入栈，继续访问该结点的左子结点，直到左子结点为空，弹出栈顶结点，访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        seq = []</span><br><span class="line">        stack = []</span><br><span class="line">        if root is None:</span><br><span class="line">            return seq</span><br><span class="line">        while((root is not None) | (len(stack) &gt; 0)):</span><br><span class="line">            if root is not None:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            else:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                seq.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        return seq</span><br></pre></td></tr></table></figure><h5 id="LeetCode144二叉树的前序遍历"><a href="#LeetCode144二叉树的前序遍历" class="headerlink" title="LeetCode144二叉树的前序遍历"></a>LeetCode144二叉树的前序遍历</h5><p>算法思路：前序遍历就是先访问该节点，然后再将该节点的左子节点入栈，如果该节点为空，则弹出栈顶元素，访问右子结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        seq = []</span><br><span class="line">        stack = []</span><br><span class="line">        if root is  None:</span><br><span class="line">            return seq</span><br><span class="line">        while((root is not None) | (len(stack) &gt; 0)):</span><br><span class="line">            if root is not None:</span><br><span class="line">                seq.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            else:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                root = root.right</span><br><span class="line">        return seq</span><br></pre></td></tr></table></figure><h5 id="LeetCode145二叉树的后序遍历"><a href="#LeetCode145二叉树的后序遍历" class="headerlink" title="LeetCode145二叉树的后序遍历"></a>LeetCode145二叉树的后序遍历</h5><p>算法思路：<strong>由于后序遍历是先访问左子结点，再访问右子节点，最后是根节点。但是如果我们按根节点，右子节点，左子节点的顺序访问，然后最后反转过来。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        seq = [] </span><br><span class="line">        stack = [] </span><br><span class="line">        if root is None:</span><br><span class="line">            return seq</span><br><span class="line">        while((root is not None)|(len(stack) &gt; 0 )):</span><br><span class="line">            if root is not None:</span><br><span class="line">                seq.append(root.val)  # first visit root node</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right # second visit rightchild node</span><br><span class="line">            else:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                root = root.left # third visit leftchild node</span><br><span class="line">        # beacause we visit by order that root,rightchild,left,</span><br><span class="line">        # so we should reverse the final result</span><br><span class="line">        return seq[::-1]</span><br></pre></td></tr></table></figure><h5 id="LeetCode102二叉树的层次遍历"><a href="#LeetCode102二叉树的层次遍历" class="headerlink" title="LeetCode102二叉树的层次遍历"></a>LeetCode102二叉树的层次遍历</h5><p>算法思路：二叉树的层次遍历实际上是广度优先搜索，在树的搜索过程中，每次都要搜索完该层然后再进入下一层，广度优先搜索的的广度就体现在树的每一层上。<strong>树的层次遍历，我们需要用一个队列来保存当前结点的左右子结点，每次从队列中存储的第一个元素出队，访问该结点，判断是否有左右子结点，如果有就入队，当队列为空则结束了遍历。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        list = []</span><br><span class="line">        seq = []</span><br><span class="line">        if root is None:</span><br><span class="line">            return seq</span><br><span class="line">        list.append(root)</span><br><span class="line">        while(len(list) &gt; 0):</span><br><span class="line">            temp = []</span><br><span class="line">            length_layer = len(list)</span><br><span class="line">            for i in range(length_layer):</span><br><span class="line">                root = list[0]</span><br><span class="line">                temp.append(root.val)</span><br><span class="line">                del list[0]</span><br><span class="line">                if root.left is not None:</span><br><span class="line">                    list.append(root.left)</span><br><span class="line">                if root.right is not None:</span><br><span class="line">                    list.append(root.right)</span><br><span class="line">            seq.append(temp)</span><br><span class="line">        return seq</span><br></pre></td></tr></table></figure><h5 id="LeetCode103二叉树的锯齿形层次遍历"><a href="#LeetCode103二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode103二叉树的锯齿形层次遍历"></a>LeetCode103二叉树的锯齿形层次遍历</h5><p>算法思路：这道题和上面那道题非常相似，唯一需要注意的地方在于偶数层的结点应该从右到左访问，奇数层的结点应该从左到右访问。所以我们可以设置一个额外的列表来保存偶数层的结点，在代码中就是temp_list，它的左右在于将偶数层的结点反转过来，然后访问temp_list中的结点。<strong>这里值得注意的是：我们不能够在访问temp_list的结点时候，顺便将该结点的左右子结点入队，这会导致下一层的访问又是从右到左的访问顺序，我们应该按原来树的每一层结构顺序，将结点的左右子结点入队，而不是按反转过来的结点顺序，将结点的左右子结点入队。</strong>我在这里被坑了一个小时，我的天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        seq = []</span><br><span class="line">        list = []</span><br><span class="line">        if root is None:</span><br><span class="line">            return seq</span><br><span class="line">        list.append(root)</span><br><span class="line">        layer = 0</span><br><span class="line">        while(len(list) &gt; 0):</span><br><span class="line">            temp = []</span><br><span class="line">            if layer % 2 == 0:</span><br><span class="line">                length_layer = len(list)</span><br><span class="line">                for i in range(length_layer):</span><br><span class="line">                    root = list[0]</span><br><span class="line">                    temp.append(root.val)</span><br><span class="line">                    del list[0]</span><br><span class="line">                    if root.left is not None:</span><br><span class="line">                        list.append(root.left)</span><br><span class="line">                    if root.right is not None:</span><br><span class="line">                        list.append(root.right)</span><br><span class="line">                seq.append(temp)</span><br><span class="line">                layer += 1</span><br><span class="line">            elif layer % 2 == 1:</span><br><span class="line">                length_layer = len(list)</span><br><span class="line">                temp_list = list[::-1]</span><br><span class="line">                for i in range(length_layer):</span><br><span class="line">                    root = temp_list[0]</span><br><span class="line">                    temp.append(root.val)</span><br><span class="line">                    del temp_list[0]</span><br><span class="line">                    root = list[0]</span><br><span class="line">                    del list[0]</span><br><span class="line">                    if root.left is not None:</span><br><span class="line">                        list.append(root.left)</span><br><span class="line">                    if root.right is not None:</span><br><span class="line">                        list.append(root.right)</span><br><span class="line">                seq.append(temp)</span><br><span class="line">                layer += 1</span><br><span class="line">        return seq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这五道题全部都是和树的遍历有关系，也是非递归的二叉树遍历写法，有前中后序三种遍历，按层遍历。总结如下。&lt;/p&gt;
&lt;h5 id=&quot;LeetCode94二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#LeetCode94二叉树的中序遍历&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>她</title>
    <link href="http://yoursite.com/2019/03/19/%E5%A5%B9/"/>
    <id>http://yoursite.com/2019/03/19/她/</id>
    <published>2019-03-19T14:46:05.000Z</published>
    <updated>2019-03-19T14:47:23.775Z</updated>
    
    <content type="html"><![CDATA[<p>我认识了一个女孩子，她和我一样爱笑。她对我很好，虽然我们之前从来没有见过，我们是在不同的地方长大，上不同的学校，成长经历也不同，但是我们却能够在台湾认识。我很笃定对于我来说她是对的人，但是现在我们还没有真正成为恋人，我决定不会再逼她一点点，两个人有两个人自己的判断，我相信很快就会有结果吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我认识了一个女孩子，她和我一样爱笑。她对我很好，虽然我们之前从来没有见过，我们是在不同的地方长大，上不同的学校，成长经历也不同，但是我们却能够在台湾认识。我很笃定对于我来说她是对的人，但是现在我们还没有真正成为恋人，我决定不会再逼她一点点，两个人有两个人自己的判断，我相信很
      
    
    </summary>
    
      <category term="只关心自己" scheme="http://yoursite.com/categories/%E5%8F%AA%E5%85%B3%E5%BF%83%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之路(五)</title>
    <link href="http://yoursite.com/2019/03/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF-%E4%BA%94/"/>
    <id>http://yoursite.com/2019/03/19/LeetCode刷题之路-五/</id>
    <published>2019-03-19T02:31:04.000Z</published>
    <updated>2019-03-19T03:10:00.727Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode33搜索旋转排序数组"><a href="#LeetCode33搜索旋转排序数组" class="headerlink" title="LeetCode33搜索旋转排序数组"></a>LeetCode33搜索旋转排序数组</h4><p>算法思路：这是一道好题。题目要求算法时间复杂度是O(logn)级别，那显然只能用<strong>二分查找</strong>了，关键在于二分查找算法只能用于有序的排列，而这道题给出的数组并不是有序的序列，在某个点上进行了旋转。<strong>那么我们应该怎么找到有序的子序列呢？</strong></p><p><strong>我们只需要判断序列的第一个值和序列中间值的大小就可以判断。因为这是一个有序的序列的必要条件。</strong></p><p>具体的，先进行判断子序列是否是 有序子序列，然后检查target的值是否在有序子序列的范围之内。不过没有我们就继续找下一个有序的子序列，如果target的值在该有序子序列的范围，就继续在这个有序子序列中使用二分查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(nums) -1</span><br><span class="line">        while(low &lt;=high):</span><br><span class="line">            middle = low + ((high-low)&gt;&gt;1)</span><br><span class="line">            if nums[middle] == target:</span><br><span class="line">                return middle</span><br><span class="line">            else:</span><br><span class="line">                if nums[low] &lt;= nums[middle]:</span><br><span class="line">                    if target &lt; nums[middle] and target &gt;= nums[low]:</span><br><span class="line">                        high = middle - 1</span><br><span class="line">                    else:</span><br><span class="line">                        low = middle + 1</span><br><span class="line">                else:</span><br><span class="line">                    if target &lt;= nums[high] and target &gt; nums[middle]:</span><br><span class="line">                        low = middle + 1</span><br><span class="line">                    else:</span><br><span class="line">                        high = middle-1</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure><h4 id="LeetCode34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode34 在排序数组中查找元素的第一个和最后一个位置"></a>LeetCode34 在排序数组中查找元素的第一个和最后一个位置</h4><p>算法思路，这道题还是考察二分查找算法，<a href="https://segmentfault.com/a/1190000008699980" target="_blank" rel="noopener">具体可以看这个链接上的二分查找总结</a>。实际上我们只要找到这个元素的第一个位置就行。然后再进行遍历找到最后一个位置。</p><p>tips：具体的要注意一些特殊例子的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(nums)-1</span><br><span class="line">        if len(nums) &lt; 0:</span><br><span class="line">            return [-1,-1]</span><br><span class="line">        if len(nums) == 1 and nums[0] ==target:</span><br><span class="line">            return [0,0]</span><br><span class="line">        elif len(nums) == 1 and nums[0] ！=target:</span><br><span class="line">            return [-1,-1]</span><br><span class="line">        while(low &lt;= high):</span><br><span class="line">            middle = low + ((high-low)&gt;&gt;1)</span><br><span class="line">            if nums[middle] &gt;= target:</span><br><span class="line">                high = middle -1</span><br><span class="line">            else:</span><br><span class="line">                low = middle + 1</span><br><span class="line">        index = high + 1 if high != len(nums)-1 and nums[high+1] == target else -1</span><br><span class="line">        if index == -1:</span><br><span class="line">            return [-1,-1]</span><br><span class="line">        else:</span><br><span class="line">            j = index</span><br><span class="line">            while(j &lt; len(nums) and nums[index] == nums[j]):</span><br><span class="line">                j += 1</span><br><span class="line">            return [index, j-1]</span><br></pre></td></tr></table></figure><h4 id="LeetCode39组合总和"><a href="#LeetCode39组合总和" class="headerlink" title="LeetCode39组合总和"></a>LeetCode39组合总和</h4><p>算法思路，这道题主要考察最基本的深度优先搜索。题目中说要使数字之和等于target，那么我们使用深度优先搜索遍历所有的情况。</p><p>唯一需要注意的是题目中说candidates中的数字可以无限制的重复被选取，所以我们假设路径中加入了”2”这个结点，从这个结点出来以后我们还是继续可以进入”2”这个结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        ength = len(candidates)</span><br><span class="line">        result = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        temp = []</span><br><span class="line">        sum = 0</span><br><span class="line">        self.DFS(0, candidates, target, sum, result, temp)</span><br><span class="line">        return result</span><br><span class="line">    def DFS(self,index,cadidate,target,sum,reauslt,temp):</span><br><span class="line">        length = len(cadidate)</span><br><span class="line">        if sum == target:</span><br><span class="line">            reauslt.append(temp.copy())</span><br><span class="line">            return</span><br><span class="line">        if index == length or sum &gt; target:</span><br><span class="line">            return</span><br><span class="line">        temp.append(cadidate[index])</span><br><span class="line">        sum += cadidate[index]</span><br><span class="line">        self.DFS(index, cadidate, target, sum, reauslt, temp)</span><br><span class="line">        temp.pop()</span><br><span class="line">        sum -= cadidate[index]</span><br><span class="line">        self.DFS(index+1, cadidate, target, sum, reauslt, temp)</span><br></pre></td></tr></table></figure><h4 id="LeetCode40组合总和二"><a href="#LeetCode40组合总和二" class="headerlink" title="LeetCode40组合总和二"></a>LeetCode40组合总和二</h4><p>算法思路：这一题和上一题的算法思路几乎一样，目前我想到的是我们每次找到一个新的组合，就先判断已有的组合中是否有重复的，但是我觉得我的算法还可以再优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        result = []</span><br><span class="line">        temp = []</span><br><span class="line">        sum = 0</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.DFS(0, target, sum, candidates, temp, result)</span><br><span class="line">        return result</span><br><span class="line">    def DFS(self,index, target, sum, candidate, temp, result):</span><br><span class="line">        if sum == target:</span><br><span class="line">            if temp not in result:</span><br><span class="line">                result.append(temp.copy())</span><br><span class="line">                return</span><br><span class="line">            else:</span><br><span class="line">                return</span><br><span class="line">        if sum &gt; target or index == len(candidate):</span><br><span class="line">            return</span><br><span class="line">        temp.append(candidate[index])</span><br><span class="line">        sum += candidate[index]</span><br><span class="line">        self.DFS(index+1, target, sum, candidate, temp, result)</span><br><span class="line">        temp.pop()</span><br><span class="line">        sum -= candidate[index]</span><br><span class="line">        self.DFS(index+1, target, sum, candidate, temp, result)</span><br></pre></td></tr></table></figure><h4 id="LeetCode41缺失的一个正数"><a href="#LeetCode41缺失的一个正数" class="headerlink" title="LeetCode41缺失的一个正数"></a>LeetCode41缺失的一个正数</h4><p>算法思路：这里有一个很妙的思路：我们先遍历一遍数组，将<strong>值在1和数组长度之间的元素放入下标为该元素值的位置</strong>，然后再遍历一遍数组，检查每个元素的值是否和下标对应，如果没有对应，那么该下标就是缺失的最小正数，如果遍历一遍都是对应好的，那么数组长度+1的元素就是缺失的最小正数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstMissingPositive(self, nums: List[int]) -&gt; int:</span><br><span class="line">            for i in range(len(nums)):</span><br><span class="line">                while(nums[i] &gt; 0 and nums[i] &lt;= len(nums) and nums[nums[i]-1] != nums[i]):</span><br><span class="line">                    temp = nums[nums[i]-1]</span><br><span class="line">                    nums[nums[i]-1] = nums[i]</span><br><span class="line">                    nums[i] = temp</span><br><span class="line">            flag = 0</span><br><span class="line">            for j in range(len(nums)):</span><br><span class="line">                if nums[j] != j+1:</span><br><span class="line">                    flag = 1</span><br><span class="line">                    return j+1</span><br><span class="line">            if flag == 0:</span><br><span class="line">                return len(nums)+1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode33搜索旋转排序数组&quot;&gt;&lt;a href=&quot;#LeetCode33搜索旋转排序数组&quot; class=&quot;headerlink&quot; title=&quot;LeetCode33搜索旋转排序数组&quot;&gt;&lt;/a&gt;LeetCode33搜索旋转排序数组&lt;/h4&gt;&lt;p&gt;算法思路：这
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之路(四)</title>
    <link href="http://yoursite.com/2019/03/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF-%E5%9B%9B/"/>
    <id>http://yoursite.com/2019/03/19/LeetCode刷题之路-四/</id>
    <published>2019-03-19T02:30:53.000Z</published>
    <updated>2019-03-19T03:09:14.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="leetcode15三数之和"><a href="#leetcode15三数之和" class="headerlink" title="leetcode15三数之和"></a>leetcode15三数之和</h4><p>算法思路：这道题我开始想到就是要固定一个数，然后要用双指针来做，但是两个指针的移动覆盖所有的数据，这样如何更新我没有想明白。</p><p>这是道好题</p><p>正确的解法应该是先将数组排序，遍历数组，固定一个数，<strong>再用双指针从这个数的右边开始遍历</strong>。如果将双指针从数组的起点和端点开始遍历，会得到很多重复的满足条件的组，因为考虑了重复的组别<strong>。所以这里要能想到将双指针从这个数的右边开始遍历就会避免考虑重复的情况而且能够覆盖到所有的情况</strong>，我画了一个简图解释一下。</p><p><img src="/images/leetcode15.jpeg" alt></p><p><strong>从最底下的5开始看，我们先遍历5右边的，然后从加入4后，重新遍历4以后的情况。重复这样一直到1，我们发现所有的情况都覆盖到了，并且不会考虑重复的组</strong>。</p><p>除此之外 算法还值得注意的地方在于：</p><ul><li>如果三个指针如果指向的当前元素与前一个元素相当，跳出本轮循环，检索下一个。</li><li>固定的指针指向的数如果大于了0，停止，因为三个数之和肯定大于了0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        list = []</span><br><span class="line">        if len(nums) &lt; 3:</span><br><span class="line">            return []</span><br><span class="line">        nums.sort()</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i] &gt;0:</span><br><span class="line">                break</span><br><span class="line">            low = i+1</span><br><span class="line">            high = len(nums)-1</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i-1]: #避免重复的组</span><br><span class="line">                continue</span><br><span class="line">            while(low &lt; high):</span><br><span class="line">                value = nums[i] + nums[low] + nums[high]</span><br><span class="line">                if value == 0:</span><br><span class="line">                    list.append([nums[i], nums[low], nums[high]])</span><br><span class="line">                    low += 1</span><br><span class="line">                    high -= 1</span><br><span class="line">                    while(low &lt; high and nums[low] == nums[low-1]): # 避免重复的组</span><br><span class="line">                        low += 1</span><br><span class="line">                    while(high &gt; low and nums[high] == nums[high+1]): # 避免重复的组</span><br><span class="line">                        high -= 1</span><br><span class="line">                if value &gt; 0:</span><br><span class="line">                    high -= 1</span><br><span class="line">                if value &lt; 0:</span><br><span class="line">                    low += 1</span><br><span class="line">        return list</span><br></pre></td></tr></table></figure><h4 id="leectcode16最接近三数之和"><a href="#leectcode16最接近三数之和" class="headerlink" title="leectcode16最接近三数之和"></a>leectcode16最接近三数之和</h4><p>算法思路：这道题和三数之和思路与很像，唯一的不同点就是要在遍历的过程中要记录和target最接近的三数之和，如何衡量接近，用绝对值就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        length = len(nums)</span><br><span class="line">        if length &lt; 3:</span><br><span class="line">            return nums</span><br><span class="line">        count = 9223372036854775807</span><br><span class="line">        nums.sort()</span><br><span class="line">        for i in range(length-2):</span><br><span class="line">            low = i+1</span><br><span class="line">            high = length-1</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i-1]:</span><br><span class="line">                i += 1</span><br><span class="line">                continue</span><br><span class="line">            while low &lt; high:</span><br><span class="line">                value = nums[i] + nums[low] + nums[high]</span><br><span class="line">                if (abs(value - target) &lt; abs(count - target)):</span><br><span class="line">                    count = value</span><br><span class="line">                if value == target:</span><br><span class="line">                    return target</span><br><span class="line">                else:</span><br><span class="line">                    if value &gt; target:</span><br><span class="line">                        high -= 1</span><br><span class="line">                    if value &lt; target:</span><br><span class="line">                        low += 1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure><h4 id="leetcode18四数之和"><a href="#leetcode18四数之和" class="headerlink" title="leetcode18四数之和"></a>leetcode18四数之和</h4><p>算法思路：和三数之和基本是一样的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        length = len(nums)</span><br><span class="line">        list = []</span><br><span class="line">        if length &lt; 4:</span><br><span class="line">            return list</span><br><span class="line">        nums.sort()</span><br><span class="line">        for i in range(length-3):</span><br><span class="line">            left = i+1</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i-1]: #这里要注意i &gt; 0的条件</span><br><span class="line">                i += 1</span><br><span class="line">                continue</span><br><span class="line">            for j in range(left, length-2):</span><br><span class="line">                if j &gt; left and nums[j] == nums[j-1]: # 同样这里要注意j &gt; left的条件</span><br><span class="line">                    j += 1</span><br><span class="line">                    continue</span><br><span class="line">                middle = j+1</span><br><span class="line">                right = length - 1</span><br><span class="line">                while(middle &lt; right):</span><br><span class="line">                    value = nums[i] + nums[j] +nums[middle] + nums[right]</span><br><span class="line">                    if target == value:</span><br><span class="line">                        list.append([nums[i], nums[j], nums[middle], nums[right]])</span><br><span class="line">                        middle += 1</span><br><span class="line">                        right -= 1</span><br><span class="line">                        while(middle &lt; right and nums[middle] == nums[middle-1]):</span><br><span class="line">                            middle += 1</span><br><span class="line">                        while(middle &lt; right and nums[right] == nums[right +1]):</span><br><span class="line">                            right -= 1</span><br><span class="line">                    elif target &lt; value:</span><br><span class="line">                        right -= 1</span><br><span class="line">                    else:</span><br><span class="line">                        middle += 1</span><br><span class="line">        return list</span><br></pre></td></tr></table></figure><h4 id="leetcode11乘最多水的容器"><a href="#leetcode11乘最多水的容器" class="headerlink" title="leetcode11乘最多水的容器"></a>leetcode11乘最多水的容器</h4><p>算法思路，如果能想到用双指针法从数组的两边开始检索，当两指针指向的矩形两边，移动较短的两边可能增加矩形的面积，而移动较长的边注定会减少矩形的面积。这道题就解决了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(height) -1</span><br><span class="line">        max_Area = 0</span><br><span class="line">        while(low &lt; high):</span><br><span class="line">            # reauslt = height[low] if height[low] &lt; height[high] else height[high]</span><br><span class="line">            max_Area = max(max_Area, min(height[low],height[high])*(high-low))</span><br><span class="line">            if height[low] &lt; height[high]:</span><br><span class="line">                low += 1</span><br><span class="line">            else:</span><br><span class="line">                high -= 1</span><br><span class="line">        return max_Area</span><br></pre></td></tr></table></figure><h4 id="leetcode31下一个排列"><a href="#leetcode31下一个排列" class="headerlink" title="leetcode31下一个排列"></a>leetcode31下一个排列</h4><p>这道题我真的要爆粗了，用评论中的一句话来说”就是这道题的每个字我都认识，连起来我就不懂了“。</p><p>我说下我理解的题意，所谓全排列就是要从从<strong>数组的右边往左</strong>边开始遍历找第一组$nums[i] &gt; nums[i-1]$。找到之后就开始在这个位置往右边遍历，然后直到找到最小的大于$nums[i-1]$的数$nums[j]$(在我的code里面这个数是$nums\lbrack index_low\rbrack$),交换$nums[i-1]$和$nums[j]$。此时我们还要保证包括$nums[i]$到$nums[lenghth-1]的元素按升序排列。</p><p>最后如果没有找到这一对数字说明整个序列已经按降序排列好了，直接反转就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def nextPermutation(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        length = len(nums)</span><br><span class="line">        flag = 0</span><br><span class="line">        for i in range(length-1, 0, -1):</span><br><span class="line">            if nums[i] &gt; nums[i-1]:</span><br><span class="line">                flag = 1</span><br><span class="line">                index_low = i</span><br><span class="line">                # 注意下面这个判断条件 中不要写成nums[index_low] &gt;= nums[i-1]!!</span><br><span class="line">                while(index_low &lt; length and nums[index_low] &gt; nums[i-1]):</span><br><span class="line">                    index_low += 1</span><br><span class="line">                tmp = nums[index_low-1]</span><br><span class="line">                nums[index_low-1] = nums[i-1]</span><br><span class="line">                nums[i-1] = tmp</span><br><span class="line">                i_right = nums[i::]</span><br><span class="line">                i_right.sort()</span><br><span class="line">                for j in range(len(i_right)):</span><br><span class="line">                    nums[i] = i_right[j]</span><br><span class="line">                    i += 1</span><br><span class="line">                break</span><br><span class="line">        if flag == 0:</span><br><span class="line">            nums.reverse()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;leetcode15三数之和&quot;&gt;&lt;a href=&quot;#leetcode15三数之和&quot; class=&quot;headerlink&quot; title=&quot;leetcode15三数之和&quot;&gt;&lt;/a&gt;leetcode15三数之和&lt;/h4&gt;&lt;p&gt;算法思路：这道题我开始想到就是要固定一个数，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之路（三）</title>
    <link href="http://yoursite.com/2019/03/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/19/LeetCode刷题之路（三）/</id>
    <published>2019-03-19T02:28:30.000Z</published>
    <updated>2019-03-19T03:07:52.125Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode35搜索插入位置"><a href="#LeetCode35搜索插入位置" class="headerlink" title="LeetCode35搜索插入位置"></a>LeetCode35搜索插入位置</h4><p>算法思路：我认为这这道题就是考察二分查找法。</p><p>常见的二分查找考察的方法有：</p><ul><li>给定一个有序的数组，查找target值是否在数组中</li><li>给定一个有序数组，查找target第一次出现的下标（同样也有最后一个出现的下标）</li><li>给定一个有序数组，查找最接近target且大于target的数的下标（最接近target且小于target的数的下标）</li></ul><p><a href="https://segmentfault.com/a/1190000008699980" target="_blank" rel="noopener">这个链接有整理好关于二分查找算法的问题的</a></p><p>说回这道题，这道题需要我们找回数组中target值的索引，如果没有则找到插入位置。其实这个问题就是上面第一个问题—<strong>给定一个有序的数组，查找target值是否在数组中</strong>，和第三个问题—<strong>给定一个有序数组，查找最接近target且大于target的数的下标</strong>的结合体。至于应该插在第一位还是最后一位直接可以进行特判（从算法复杂度的角度来说，出现这两种情况是二分查找最差的情况）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">#        if target &lt; nums[0]:</span><br><span class="line">#            return 0</span><br><span class="line">#        if target &gt; nums[-1]:</span><br><span class="line">#            return len(nums)</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(nums) - 1</span><br><span class="line">        while(low &lt;= high):</span><br><span class="line">            middle = low +((high - low)&gt;&gt;1)</span><br><span class="line">            if nums[middle] == target:</span><br><span class="line">                return middle</span><br><span class="line">            elif nums[middle] &lt; target:</span><br><span class="line">                low = middle +1</span><br><span class="line">            else:</span><br><span class="line">                high = middle-1</span><br><span class="line">        return high + 1</span><br></pre></td></tr></table></figure><hr><h4 id="LeetCode38报数"><a href="#LeetCode38报数" class="headerlink" title="LeetCode38报数"></a>LeetCode38报数</h4><p>算法思路：这道题如果读懂了题意，那么就这个问题就简单了。</p><p>题意：比如说“1211”，就是一个1，一个2，两个1组成，所以下一个报数我们要输出“111221”，再比如说“111221”，由三个1，二个2，一个1组成，所以下一个我们要输出”312211“</p><p>每一项报数都是基于前一项的结果生成的。统计相同的数字，当遇到不相同的数字就要输出结果，然后继续统计下一个数字。我的算法需要注意的是在<strong>循环体中当j等于最后一个数了必须要输出当前的字符串</strong>。</p><h4 id="class-Solution"><a href="#class-Solution" class="headerlink" title="class Solution:"></a>class Solution:</h4><pre><code>def countAndSay(self, n: int) -&gt; str:    d = {}    for i in range(1, 31):        d.setdefault(i, &quot;&quot;)    d[1] = &apos;1&apos;    d[2] = &apos;11&apos;    for i in range(3, 31):        count = 0        tmp_case = &quot;&quot;        tmp = d[i-1][0]        for j in range(len(d[i-1])):            if tmp == d[i-1][j]:                count += 1            else:                tmp_case = tmp_case+str(count)+str(tmp)                tmp = d[i-1][j]                count = 1            if j == (len(d[i - 1]) - 1):                tmp_case = tmp_case + str(count) + str(tmp)        d[i] = tmp_case    return d[n]</code></pre><h4 id="LeetCode2两数相加"><a href="#LeetCode2两数相加" class="headerlink" title="LeetCode2两数相加"></a>LeetCode2两数相加</h4><p>算法：就是模拟两个数相加，只是需要考虑不同情况的进位。</p><p>具体的进位有普通的进位；两个数位数一样，最后的一位相加后产生进位；两个数位数不一样，比如123，9740中，“3”和“7”相加产生进位，“9”加上之前进位的“1”还要产生进位。这几种进位情况考虑到了就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        r = ListNode(0)</span><br><span class="line">        p = r</span><br><span class="line">        count = 0</span><br><span class="line">        while(l1 and l2):</span><br><span class="line">            tmp = ListNode(0)</span><br><span class="line">            tmp.val = l1.val + l2.val if count == 0 else l1.val + l2.val +1</span><br><span class="line">            count = 0</span><br><span class="line">            if tmp.val &gt;= 10:</span><br><span class="line">                count = 1</span><br><span class="line">                tmp.val -= 10</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next </span><br><span class="line">        if count == 1 and l1 is None and l2 is None:</span><br><span class="line">            tmp = ListNode(1)</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            return r.next</span><br><span class="line">        while l1:</span><br><span class="line">            tmp = ListNode(0)</span><br><span class="line">            tmp.val = l1.val if count == 0 else l1.val +1</span><br><span class="line">            count = 0</span><br><span class="line">            if tmp.val &gt;= 10:</span><br><span class="line">                count = 1</span><br><span class="line">                tmp.val -= 10</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        if count == 1:</span><br><span class="line">            tmp = ListNode(1)</span><br><span class="line">            p.next = tmp   </span><br><span class="line">        while l2:</span><br><span class="line">            tmp = ListNode(0)</span><br><span class="line">            tmp.val =l2.val if count == 0 else l2.val +1</span><br><span class="line">            count = 0</span><br><span class="line">            if tmp.val &gt;= 10:</span><br><span class="line">                count = 1</span><br><span class="line">                tmp.val -= 10</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        if count == 1:</span><br><span class="line">            tmp = ListNode(1)</span><br><span class="line">            p.next = tmp  </span><br><span class="line">        return r.next</span><br></pre></td></tr></table></figure><h4 id="LeetCode3无重复字符的最长子串"><a href="#LeetCode3无重复字符的最长子串" class="headerlink" title="LeetCode3无重复字符的最长子串"></a>LeetCode3无重复字符的最长子串</h4><p>算法思路：最开始写了个O(n^3)的暴力算法。最后看了下讨论里面发现有一个新的思路：</p><p>将每一个字符加入一个字符串中，依次检查字符串的字符是否已经存在该子串中，没有加加入，当前子串匹配失败时，子串并不需退回去重新匹配，而是将找到当前子串中失配的位置，从下一位重新开始匹配（因为子串中已经存在个相同的字符了，所以从下一个开始匹配） 每次发生失配就返回当前子串的长度。</p><p>tips：当整个字符串检索完毕还要输出还要更新一次<strong>无重复字符串长度</strong>，因为在for循环中只有发生失配才会更新无重复字符串长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        str = &apos;&apos;  </span><br><span class="line">        max_count = 0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] not in str:</span><br><span class="line">                str +=  s[i]</span><br><span class="line">            else:</span><br><span class="line">                if max_count &lt; len(str):</span><br><span class="line">                    max_count = len(str)</span><br><span class="line">                str = str[str.index(s[i])+1:]</span><br><span class="line">                str += s[i]</span><br><span class="line">        if max_count &lt; len(str):</span><br><span class="line">            max_count = len(str)</span><br><span class="line">        return max_count</span><br></pre></td></tr></table></figure><h4 id="LeetCode5最长回文子串"><a href="#LeetCode5最长回文子串" class="headerlink" title="LeetCode5最长回文子串"></a>LeetCode5最长回文子串</h4><p>算法思路，这道题有很多种思路，我使用动态规划的方法来解决。</p><p>当我们已经判断一个字符串是一个回文串时,假设我们现在已经获得下标从$i$到$j$的字符串,即$s_{i-1,j-1}$是一个回文串,如果$s_{i}=\;s_{j}$,那么$s_{i,j}$就是一个回文串，这种情况适用于回文子串长度大于等于3。当长度为1，和2时得初始化。所以我们可以得到一个这样的状态转移方程：</p><p>$$dp\lbrack i\rbrack\lbrack j\rbrack=\left{\begin{array}{lc}1&amp;dp\lbrack i+1\rbrack\lbrack j-1\rbrack=0\;and\;s_i=s_j\0&amp;dp\lbrack i+1\rbrack\lbrack j-1\rbrack\;!=0\;or\;s_i\;!=s_j\end{array}\right.$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        length = len(s)</span><br><span class="line">        if s == &quot;&quot;:</span><br><span class="line">            return s</span><br><span class="line">        dp = [[0 for i in range(length)] for j in range(length)]</span><br><span class="line">        max_length = 0</span><br><span class="line">        count = 1</span><br><span class="line">        for i in range(length): # 初始化dp数组</span><br><span class="line">            dp[i][i] = 1</span><br><span class="line">            if i &lt; length -1:</span><br><span class="line">                if s[i] == s[i+1]:</span><br><span class="line">                    dp[i][i+1] = 1</span><br><span class="line">                    #dp[i+1][i] = 1</span><br><span class="line">                    count = 2</span><br><span class="line">        if length &lt; 3:</span><br><span class="line">            if count == 2:</span><br><span class="line">                return s</span><br><span class="line">            elif dp[0][0] == 1:</span><br><span class="line">                return s[0]</span><br><span class="line">        for len_substring in range(3, length+1): # 枚举每个子串可能的长度</span><br><span class="line">            for i in range(length+1-len_substring):</span><br><span class="line">                j = i+len_substring-1</span><br><span class="line">                if s[i] == s[j] and dp[i+1][j-1] == 1:</span><br><span class="line">                    dp[i][j] = 1</span><br><span class="line">        index_i = 0</span><br><span class="line">        index_j = 0</span><br><span class="line">        for i in range(length):</span><br><span class="line">            for j in range(length):</span><br><span class="line">                if dp[i][j] == 1:</span><br><span class="line">                    count = j-i</span><br><span class="line">                    if count &gt; max_length:</span><br><span class="line">                        max_length = count</span><br><span class="line">                        index_i = i</span><br><span class="line">                        index_j = j</span><br><span class="line">        return s[index_i:index_j+1]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode35搜索插入位置&quot;&gt;&lt;a href=&quot;#LeetCode35搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;LeetCode35搜索插入位置&quot;&gt;&lt;/a&gt;LeetCode35搜索插入位置&lt;/h4&gt;&lt;p&gt;算法思路：我认为这这道题就是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(二)</title>
    <link href="http://yoursite.com/2019/03/05/LeetCode%E5%88%B7%E9%A2%98-%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/03/05/LeetCode刷题-二/</id>
    <published>2019-03-05T11:04:26.000Z</published>
    <updated>2019-03-19T03:05:58.673Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode20有效的括号"><a href="#LeetCode20有效的括号" class="headerlink" title="LeetCode20有效的括号"></a>LeetCode20有效的括号</h4><p>算法思路：这道题就是一个栈就能解决，不多说，碰到’(‘,’[‘,’{‘,入栈，遇到’)’,’]’,’}’。弹出栈顶的元素，匹配是否是一对a，不是则结束输出无效。如果所有的输入完成，栈不为空，输出无效，其它情况都是有效的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: &apos;str&apos;) -&gt; &apos;bool&apos;:</span><br><span class="line">        if s ==&quot;&quot;:</span><br><span class="line">            return True</span><br><span class="line">        char_list = []</span><br><span class="line">        for char in s:</span><br><span class="line">            if char ==&apos;(&apos; or char == &apos;[&apos; or char == &apos;&#123;&apos;:</span><br><span class="line">                char_list.append(char)</span><br><span class="line">            elif char ==&apos;)&apos;:</span><br><span class="line">                if len(char_list) and char_list[-1]==&apos;(&apos;:</span><br><span class="line">                    char_list.pop()</span><br><span class="line">                else:</span><br><span class="line">                    return False</span><br><span class="line">            elif char == &apos;]&apos;:</span><br><span class="line">                if len(char_list) and char_list[-1]==&apos;[&apos;:</span><br><span class="line">                    char_list.pop()</span><br><span class="line">                else:</span><br><span class="line">                    return False</span><br><span class="line">            elif char == &apos;&#125;&apos;:</span><br><span class="line">                if len(char_list) and char_list[-1]==&apos;&#123;&apos;:</span><br><span class="line">                    char_list.pop()</span><br><span class="line">                else:</span><br><span class="line">                    return False</span><br><span class="line">        if len(char_list) == 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><h4 id="LeetCode21合并两个有序链表"><a href="#LeetCode21合并两个有序链表" class="headerlink" title="LeetCode21合并两个有序链表"></a>LeetCode21合并两个有序链表</h4><p>算法思路：使用归并排序的思路，比较两个节点值的大小，小的则插入新的链表中，依次比较，直到一条链表比较完成，将另外一条链表加入到新的链表尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: &apos;ListNode&apos;, l2: &apos;ListNode&apos;) -&gt; &apos;ListNode&apos;:</span><br><span class="line">        r = ListNode(0)</span><br><span class="line">        head = r</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt;= l2.val:</span><br><span class="line">                head.next = l1</span><br><span class="line">                head = head.next</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            else:</span><br><span class="line">                head.next = l2</span><br><span class="line">                head = head.next</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        if l1:</span><br><span class="line">            head.next = l1</span><br><span class="line">        if l2:</span><br><span class="line">            head.next = l2</span><br><span class="line">        return r.next</span><br></pre></td></tr></table></figure><h4 id="LeetCode26删除排序数组中的重复项"><a href="#LeetCode26删除排序数组中的重复项" class="headerlink" title="LeetCode26删除排序数组中的重复项"></a>LeetCode26删除排序数组中的重复项</h4><p>算法思路：哈希思想，将出现的元素作为键，将出现次数记录下来。再遍历一边哈希表，将出现次数大于一的key写到nums中。</p><p>tips：题目描述没有说清楚，事实上是需要返回最后nums的长度，不是nums</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        c = &#123;&#125;</span><br><span class="line">        for i in nums:</span><br><span class="line">            c.setdefault(i,0)</span><br><span class="line">            c[i] += 1</span><br><span class="line">        j = 0</span><br><span class="line">        for key in c:</span><br><span class="line">            if c[key] &gt;= 1:</span><br><span class="line">                nums[j] = key</span><br><span class="line">                j +=1</span><br><span class="line">        return j</span><br></pre></td></tr></table></figure><h4 id="LeetCode27移除元素"><a href="#LeetCode27移除元素" class="headerlink" title="LeetCode27移除元素"></a>LeetCode27移除元素</h4><p>算法思路：思路和上题一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElement(self, nums: List[int], val: int) -&gt; int:</span><br><span class="line">        c = &#123;&#125;</span><br><span class="line">        count = 0</span><br><span class="line">        for i in nums:</span><br><span class="line">            if i != val:</span><br><span class="line">                c.setdefault(i,0)</span><br><span class="line">                c[i] += 1</span><br><span class="line">                count += 1</span><br><span class="line">        j = count</span><br><span class="line">        for key in c:</span><br><span class="line">            for i in range(0,c[key]):</span><br><span class="line">                nums[count-1] = key   </span><br><span class="line">                count -=1</span><br><span class="line">        return j</span><br></pre></td></tr></table></figure><h4 id="LeetCode28实现strStr"><a href="#LeetCode28实现strStr" class="headerlink" title="LeetCode28实现strStr()"></a>LeetCode28实现strStr()</h4><p>算法思路：这道题就是考察暴力搜索算法和kmp算法的。kmp算法的关键在于理解next数组的生成，next[i]代表子串s[0,…i]的最长相等前后缀的前缀的最后一位下标。</p><p>而next数组的求解过程如下：</p><p>1.初始化next数组，并且j=next[0] = -1。</p><p>2.遍历 i从1到length-1</p><p>3.不断令j = next[j],直到j=-1或者s[i] = s[j+1]</p><p>4.如果s[i] = s[j+1],则next[i] = j+1,否则next[i] = j</p><p>而kmp将模式串和子串进行匹配的过程就和求解next数组一致，唯一不同的就是从模式串的第一位开始，而求解next数组是从第二位开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        len_needle = len(needle)</span><br><span class="line">        len_haystack = len(haystack)</span><br><span class="line">        index = 0</span><br><span class="line">        if len_needle == 0:</span><br><span class="line">            return index</span><br><span class="line">        def getnext(length_pattern,pattern):</span><br><span class="line">            j = - 1</span><br><span class="line">            next = list(range(len_needle))</span><br><span class="line">            next[0] = -1</span><br><span class="line">            for i in range(1,length_pattern):</span><br><span class="line">                while(j != -1 and pattern[i] != pattern[j+1]):</span><br><span class="line">                    j = next[j]</span><br><span class="line">                if pattern[i] == pattern[j+1]:</span><br><span class="line">                    j += 1</span><br><span class="line">                next[i] = j</span><br><span class="line">            return next</span><br><span class="line">        next = getnext(len_needle,needle)</span><br><span class="line">        print(next)</span><br><span class="line">        j = -1</span><br><span class="line">        for i in range(len_haystack):</span><br><span class="line">            while(j != -1 and haystack[i] != needle[j+1]):</span><br><span class="line">                j = next[j]</span><br><span class="line">            if haystack[i] == needle[j+1]:</span><br><span class="line">                j += 1</span><br><span class="line">            if j == len_needle -1:</span><br><span class="line">                index = i + 1 - len_needle</span><br><span class="line">                return index</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode20有效的括号&quot;&gt;&lt;a href=&quot;#LeetCode20有效的括号&quot; class=&quot;headerlink&quot; title=&quot;LeetCode20有效的括号&quot;&gt;&lt;/a&gt;LeetCode20有效的括号&lt;/h4&gt;&lt;p&gt;算法思路：这道题就是一个栈就能解决，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题（一）</title>
    <link href="http://yoursite.com/2019/02/25/LeetCode%E5%88%B7%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/25/LeetCode刷题（一）/</id>
    <published>2019-02-25T06:38:52.000Z</published>
    <updated>2019-03-19T03:04:58.192Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode1-两数之和-2019-2-17日"><a href="#LeetCode1-两数之和-2019-2-17日" class="headerlink" title="LeetCode1.两数之和(2019.2.17日)"></a>LeetCode1.两数之和(2019.2.17日)</h4><p>直接思路：暴力求解</p><p>从list的两端开始遍历，一直遍历到两端指向同一个元素，如果遍历过程中找到了两个元素之和等于target，返回索引，没有则将首端的指针指向下一个元素。显然算法复杂度为O(n2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        length = len(nums)</span><br><span class="line">        for i in range(length-1):</span><br><span class="line">            for j in range(length-1,i,-1):</span><br><span class="line">                   if nums[i] +nums[j] == target:</span><br><span class="line">                       return [i,j]</span><br></pre></td></tr></table></figure><p>改进算法：哈希表</p><p>将每个值的索引存入哈希表中，遍历list的每一元素value，求出target-value值，用这个值去哈希表中寻找对应的索引，找到即返回。算法复杂度为O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        for i,value in enumerate(nums):</span><br><span class="line">            tmp = target - value</span><br><span class="line">            if tmp in hashmap:</span><br><span class="line">                return [i,hashmap[tmp]]</span><br><span class="line">            hashmap[value] = i</span><br></pre></td></tr></table></figure><h4 id="LeetCode7-整数反转"><a href="#LeetCode7-整数反转" class="headerlink" title="LeetCode7.整数反转"></a>LeetCode7.整数反转</h4><p>思路：获得每个位上的数字，具体可以通过%10操作获得个位数字压入队列中，再整除10，再%10获得十位上的数字，直到最后一位，将最后一位压入队列中。如果整数小于0，预先把符号保存下来，正数就不需要管。其次就是120,1230这种最后以0结尾的数，在反转后的数字第一位不能是0，所以我们需要从队列第一个不为0的数字开始恢复，依次将队列里面的数字出队，乘以10，再加上下一个出队数字，再乘以10。最后还要检查反转后的数字是否溢出！有个测试样例1534236469反转后的9646327351就溢出了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        tmp = []</span><br><span class="line">        flag1 = 1</span><br><span class="line">        if x &lt; 0:</span><br><span class="line">            x *= -1</span><br><span class="line">            flag1 = -1</span><br><span class="line">        if -10&lt;x&lt;10:</span><br><span class="line">            return x*flag1</span><br><span class="line">        flag = 1</span><br><span class="line">        while(flag):</span><br><span class="line">            count = x % 10</span><br><span class="line">            tmp.append(count)</span><br><span class="line">            x = x // 10</span><br><span class="line">            if x &lt; 10:</span><br><span class="line">                flag = 0</span><br><span class="line">                tmp.append(x)</span><br><span class="line">        newx,counts = (0,0)</span><br><span class="line">        for i in range(len(tmp)):</span><br><span class="line">            if tmp[i] != 0:</span><br><span class="line">                counts = i</span><br><span class="line">                break</span><br><span class="line">        for j in range(counts, len(tmp)):</span><br><span class="line">            newx += tmp[j]</span><br><span class="line">            if j != len(tmp)-1:</span><br><span class="line">                newx *= 10</span><br><span class="line">        if -2**31&lt;newx*flag1&lt;2**31 -1:</span><br><span class="line">            return newx*flag1</span><br><span class="line">        else:</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure><h4 id="LeetCode9-回文数"><a href="#LeetCode9-回文数" class="headerlink" title="LeetCode9.回文数"></a>LeetCode9.回文数</h4><p>思路：这其实是一个字符串反转的问题，没什么好说的。python中字符串反转的方法还有递归的思路，用栈，用字符串的分片操作，还有reversed函数一共五种，<a href="https://www.geeksforgeeks.org/reverse-string-python-5-different-ways/" target="_blank" rel="noopener">具体参考这个网址</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        x_str = str(x)</span><br><span class="line">        y_str = &quot;&quot;</span><br><span class="line">        for i in x_str:</span><br><span class="line">            y_str = i + y_str</span><br><span class="line">        count = 0</span><br><span class="line">        for i in range(len(x_str)):</span><br><span class="line">            if x_str[i] == y_str[i]:</span><br><span class="line">                count += 1</span><br><span class="line">        if count == len(x_str):</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><p>LeetCode13.罗马数转换成整数</p><p>思路：这个问题我们可以直接将罗马数字和整数之间转换关系用字典表示，然后再判断”IV”,”IX”,”XL”,”XC”,”CD”,”CM”这六种特殊情况。罗马数字转换到整数直接将每个字符串按位相加就可以了。</p><p>Tips：我的解法有个小问题就是需要注意判断那六种特殊情况是，需要加上”索引i大于0”条件,不加的话，碰到”XXVII“这类会输出25而不是27，因为第一个”X“会被判定为8而不是10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        index_dic=&#123;&apos;I&apos;:1,&apos;V&apos;:5,&apos;X&apos;:10,&apos;L&apos;:50,&apos;C&apos;:100,&apos;D&apos;:500,&apos;M&apos;:1000&#125;</span><br><span class="line">        value_int=0</span><br><span class="line">        for i,value in enumerate(s):</span><br><span class="line">            if s[i] == &apos;V&apos; and s[i-1] == &apos;I&apos; and i &gt; 0:</span><br><span class="line">                value_int += 3</span><br><span class="line">            elif s[i] == &apos;X&apos; and s[i-1] == &apos;I&apos; and i &gt; 0:</span><br><span class="line">                value_int += 8</span><br><span class="line">            elif s[i] == &apos;L&apos; and s[i-1] == &apos;X&apos;and i &gt; 0:</span><br><span class="line">                value_int += 30</span><br><span class="line">            elif s[i] == &apos;C&apos; and s[i-1] == &apos;X&apos;and i &gt; 0:</span><br><span class="line">                value_int += 80</span><br><span class="line">            elif s[i] == &apos;D&apos; and s[i-1] == &apos;C&apos;and i &gt; 0:</span><br><span class="line">                value_int += 300</span><br><span class="line">            elif s[i] == &apos;M&apos; and s[i-1] == &apos;C&apos;and i &gt; 0:</span><br><span class="line">                value_int += 800</span><br><span class="line">            else:</span><br><span class="line">                value_int += index_dic[s[i]]</span><br><span class="line">        return value_int</span><br></pre></td></tr></table></figure><h4 id="LeetCode14-最长公共前缀"><a href="#LeetCode14-最长公共前缀" class="headerlink" title="LeetCode14.最长公共前缀"></a>LeetCode14.最长公共前缀</h4><p>算法：我的算法解这道题基于一个前提：<strong>最长的公共前缀的长度必定小于等于字符串数组中最短的那个字符串</strong>。所以先用字符串排序取得最短长度的字符串a。按顺序取出a的每一位，与字符串数组剩下的每一个字符串同样的位置比较是否相等，相等则将这一位存储到list中，继续比较，如果不相等就不需要继续比较了。此时判断list中有0个字符还是大于0个字符，一个字符就返回”“（第一个字符就不相等），多个字符就返回除了当前字符以外别的字符(因为当前字符不相等)。如果最短字符串的所有字符都比较完毕，那么久输出这个最短字符即可。</p><p>注意需要判断[]和[“”]这两种情况。需要进行特判。我的这个算法在时间复杂度上是最优算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: &apos;List[str]&apos;) -&gt; &apos;str&apos;:</span><br><span class="line">        if len(strs) == 0:</span><br><span class="line">            str = &quot;&quot;</span><br><span class="line">            return str</span><br><span class="line">        strs.sort(key=len)</span><br><span class="line">        short_list = []</span><br><span class="line">        if strs[0] == &quot;&quot;:</span><br><span class="line">            str = &quot;&quot;</span><br><span class="line">            return str</span><br><span class="line">        for i in range(len(strs[0])):</span><br><span class="line">            tmp=strs[0][i]</span><br><span class="line">            short_list.append(tmp)</span><br><span class="line">            flag = 0</span><br><span class="line">            for j in range(len(strs)):</span><br><span class="line">                if strs[j][i] != tmp:</span><br><span class="line">                    flag = 1</span><br><span class="line">            if flag and len(short_list)==0:</span><br><span class="line">                str = &quot;&quot;</span><br><span class="line">                return str</span><br><span class="line">            elif flag and len(short_list) &gt; 0:</span><br><span class="line">                str = &quot;&quot;.join(short_list[:-1])</span><br><span class="line">                return str</span><br><span class="line">        if i == len(strs[0])-1:</span><br><span class="line">            str = &quot;&quot;.join(short_list)</span><br><span class="line">            return str</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode1-两数之和-2019-2-17日&quot;&gt;&lt;a href=&quot;#LeetCode1-两数之和-2019-2-17日&quot; class=&quot;headerlink&quot; title=&quot;LeetCode1.两数之和(2019.2.17日)&quot;&gt;&lt;/a&gt;LeetCode1.
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>理解Python中的defaultdictt</title>
    <link href="http://yoursite.com/2019/02/25/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84defaultdict/"/>
    <id>http://yoursite.com/2019/02/25/理解Python中的defaultdict/</id>
    <published>2019-02-25T06:35:22.000Z</published>
    <updated>2019-02-25T06:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，如果访问字典中不存在的键时会引发KeyError的异常。但是如果字典中的键如果能够有默认的值有时候是非常方便的。比如以下的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for i in strings:</span><br><span class="line">counts[i] += 1</span><br></pre></td></tr></table></figure><p>以上这个例子是用来统计单词出现的次数，将单词作为count中的键，单词每出现一次就加1.事实上这段代码是会抛出KeyError的。</p><p>有以下几个办法能够处理这个问题。</p><h5 id="使用判断语句检查"><a href="#使用判断语句检查" class="headerlink" title="使用判断语句检查"></a>使用判断语句检查</h5><hr><p>我们可以在每次取得单词时候，检查这个单词是否在字典中有默认值，没有就赋一个默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for i in strings:</span><br><span class="line">if i not in count:</span><br><span class="line">counts[i] = 0</span><br><span class="line">counts[i] += 1</span><br></pre></td></tr></table></figure><h5 id="dict-setdefault-方法"><a href="#dict-setdefault-方法" class="headerlink" title="dict.setdefault()方法"></a>dict.setdefault()方法</h5><hr><p>我们也可以使用dict.setdefault()方法来设置默认值：这个方法结构两个参数，一个是键的名称，另一个是默认值。如果键已经存在字典中就返回它的值，如果没有就将默认值保存并且返回该默认值。用dict.setdefault()重写上面的例子</p><blockquote><p><code>setdefault</code>(<em>key</em>[, <em>default</em>])</p><p>If <em>key</em> is in the dictionary, return its value. If not, insert <em>key</em> with a value of <em>default</em> and return <em>default</em>. <em>default</em> defaults to <code>None</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for i in strings:</span><br><span class="line">counts.setdefault(i,0)</span><br><span class="line">counts[i] += 1</span><br></pre></td></tr></table></figure><p>下面这种方法就是我们本篇博客的主角collections.defaultdict类</p><h5 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h5><hr><blockquote><p><em>class</em> <code>collections.`</code>defaultdict`([<em>default_factory</em>[, <em>…</em>]])</p></blockquote><p>defaultdict类返回一个类似于的字典对象，第一个参数给default_factory属性赋值，其它的参数都传递给dict构造器。<strong>通俗来说就是defaultdict类的初始化函数接收一个类型作为参数，当访问的键不存在，实例化一个值作为默认值</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(list)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;lei&apos;]</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;lei&apos;: []&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;wang&apos;].append(22)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;lei&apos;: [], &apos;wang&apos;: [22]&#125;)</span><br></pre></td></tr></table></figure><p>但是这种使用仅限于直接通过访问字典的键dict[key]或者dict.__getitem__()这两种方式，如下面的例子，其它的使用都不行，具体原因稍后介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;xu&apos; in dd</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; dd.pop(&apos;xu&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    dd.pop(&apos;xu&apos;)</span><br><span class="line">KeyError: &apos;xu&apos;</span><br><span class="line">&gt;&gt;&gt; dd.get(&apos;xu&apos;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;xu&apos;]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>该类除了接收类型名称来作为初始化函数的参数，还可以使用任何不带参数的可调用函数作为参数，函数的返回结果就作为默认值，这样可以使得默认值的取值更加灵活。下面的例子是介绍这种用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; def one():</span><br><span class="line">return 1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(one)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;function one at 0x1101ff2f0&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;lei&apos;]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;function one at 0x1101ff2f0&gt;, &#123;&apos;lei&apos;: 1&#125;)</span><br></pre></td></tr></table></figure><p>同样我们也可以使用匿名函数lambda来作为参数，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = defaultdict(lambda: 0)</span><br><span class="line">for i in strings:</span><br><span class="line">counts[i] +=1</span><br></pre></td></tr></table></figure><p>为什么defaultdict类可以实现这样的用法呢，因为它支持<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">__missing__()方法</a>。</p><blockquote><p><em>class</em> <code>collections.`</code>defaultdict`([<em>default_factory</em>[, <em>…</em>]])</p><p><code>__missing__</code>(<em>key</em>)</p><p>If the <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> attribute is <code>None</code>, this raises a <a href="https://docs.python.org/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> exception with the <em>key</em> as argument.</p><p>If <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> is not <code>None</code>, it is called without arguments to provide a default value for the given <em>key</em>, this value is inserted in the dictionary for the <em>key</em>, and returned.</p><p>If calling <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> raises an exception this exception is propagated unchanged.</p><p>This method is called by the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> method of the <a href="https://docs.python.org/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> class when the requested key is not found; whatever it returns or raises is then returned or raised by <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>.</p><p>Note that <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.__missing__" target="_blank" rel="noopener"><code>__missing__()</code></a> is <em>not</em> called for any operations besides <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>. This means that <code>get()</code> will, like normal dictionaries, return <code>None</code> as a default rather than using<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a></p></blockquote><p> 从第二句我们可以看到如果default_factory不是None,调用时会给给定的key一个默认值，这个默认值会保存在key对应的之中，并且被返回。第四句说明这个方法只会被 __getitem__()方法调用,dict[key]这种形式实际上是__getitem__方法的简化形式。</p><p>当__getitem__()方法访问一个不存在的键时会调用__missing__()方法获得默认的值，将该键添加到字典中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(defaultdict.__missing__.__doc__)</span><br><span class="line">__missing__(key) # Called by __getitem__ for missing key; pseudo-code:</span><br><span class="line">  if self.default_factory is None: raise KeyError((key,))</span><br><span class="line">  self[key] = value = self.default_factory()</span><br><span class="line">  return value</span><br></pre></td></tr></table></figure><h5 id="实现一个defaultdict功能"><a href="#实现一个defaultdict功能" class="headerlink" title="实现一个defaultdict功能"></a>实现一个defaultdict功能</h5><hr><p>在<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" target="_blank" rel="noopener">”dict“</a>python文档中还介绍，如果dict的子类实现了__missing__方法，当访问不存在的键时，dict[key]会调用__missing__（）方法来获得默认值。下面我们可以进一步实验，定义一个dict的子类Missing并且实现__missing__()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Missing(dict):</span><br><span class="line">def __missing__(self,key):</span><br><span class="line">return &apos;missing&apos;</span><br><span class="line">&gt;&gt;&gt; d = Missing()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;lei&apos;]</span><br><span class="line">&apos;missing&apos;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回结果表明__missing__()方法确实发挥了作用，但是key没有添加到字典当中去，我们再修改一下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class defaultdict(dict):</span><br><span class="line">def __missing__(self,key):</span><br><span class="line">self[key] = &apos;wanglei&apos;</span><br><span class="line">return &apos;wanglei&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dd=defaultdict()</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; dd[&apos;foo&apos;]</span><br><span class="line">&apos;wanglei&apos;</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">&#123;&apos;foo&apos;: &apos;wanglei&apos;&#125;</span><br></pre></td></tr></table></figure><h5 id="在旧的Python版本中实现defaultdict功能"><a href="#在旧的Python版本中实现defaultdict功能" class="headerlink" title="在旧的Python版本中实现defaultdict功能"></a>在旧的Python版本中实现defaultdict功能</h5><hr><p>本来这个我不想写了，但是我觉得有必要综合一下上面所说的。defaultdict类是在Python2.5中加入进来的，但是我们可以实现一个兼容defaultdict的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class defaultdict(dict):</span><br><span class="line">    # 首先当 __getitem__()方法访问键失败的时候，调用__missing__方法。</span><br><span class="line">def __getitem__(self,key):</span><br><span class="line">try:</span><br><span class="line">return dict.__getitem__(self,key)</span><br><span class="line">except KeyError:</span><br><span class="line">return self.__missing__(key)</span><br><span class="line"># 实现__missing__方法来给设置默认值</span><br><span class="line">def __missing__(key):</span><br><span class="line">self[key] =value = self.default_factory()</span><br><span class="line">return value</span><br></pre></td></tr></table></figure><p>然后defaultdict类的初始化函数__init__()需要接收类型或者可调用函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class defaultdict(dict):</span><br><span class="line">    def __init__(self,default_factory=None,*a,**kwag):</span><br><span class="line">    dict.__init__(self,*a,**kwag)</span><br><span class="line">    self.default_factory = default_factory</span><br><span class="line">    # 首先当 __getitem__()方法访问键失败的时候，调用__missing__方法。</span><br><span class="line">def __getitem__(self,key):</span><br><span class="line">try:</span><br><span class="line">return dict.__getitem__(self,key)</span><br><span class="line">except KeyError:</span><br><span class="line">return self.__missing__(key)</span><br><span class="line"># 实现__missing__方法来给设置默认值</span><br><span class="line">def __missing__(key):</span><br><span class="line">self[key] =value = self.default_factory()</span><br><span class="line">return value</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>本文主要参考了这篇</p><p><a href="http://kodango.com/understand-defaultdict-in-python" target="_blank" rel="noopener">http://kodango.com/understand-defaultdict-in-python</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python中，如果访问字典中不存在的键时会引发KeyError的异常。但是如果字典中的键如果能够有默认的值有时候是非常方便的。比如以下的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="Python学习" scheme="http://yoursite.com/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="defaultdict" scheme="http://yoursite.com/tags/defaultdict/"/>
    
  </entry>
  
  <entry>
    <title>如何提取出一首歌曲的梅尔频谱</title>
    <link href="http://yoursite.com/2019/02/18/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E5%87%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E6%9B%B2%E7%9A%84%E6%A2%85%E5%B0%94%E9%A2%91%E8%B0%B1/"/>
    <id>http://yoursite.com/2019/02/18/如何提取出一首歌曲的梅尔频谱/</id>
    <published>2019-02-18T12:17:26.000Z</published>
    <updated>2019-02-18T12:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.声谱图</p><p>如下图1一段声音信号直观地看起来是时间和能量的关系，在语音识别，音乐信息检索中常常关注的是声音中频率和能量的关系，即声谱图描述的就是频率和能量的关系。所以我们拿到一段音频需要先进行初步的处理，获得它的声谱图。具体的做法则是将声音信号分帧，然后对每一帧都用短时傅里叶变换处理，当然进行傅里叶变换之前还预先需要对声音信号进行预加重，加窗。</p><p><img src="/images/声波图.jpg" alt></p><p>2.梅尔频谱</p><p>由于人耳对声音的感知不是线性的，人耳对声音的低频比对声音的高频更加敏感。所以常常需要将线性频谱转换到非线性的梅尔频谱。普通频率转换到梅尔频率的公式是<br>$$<br>m=2595log_{10}(1+\frac f{700})<br>$$<br>我们将一组频域信号通过梅尔滤波器组就可以获得梅尔频谱。</p><p>总结一下获得梅尔频谱的大概流程：首先对时域信号进行傅里叶变换转换到频域，然后再利用梅尔频率刻度的滤波器组对应频域信号进行处理，就可以得到梅尔频谱。这个流程可以使用<a href="https://librosa.github.io/librosa/index.html" target="_blank" rel="noopener">librosa库</a>来完成，下面就是相应的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import librosa</span><br><span class="line">import numpy as np</span><br><span class="line">def get_melcepstrum(audio_path,mel_save_path):</span><br><span class="line">y, sr = librosa.load(aduio_path,sr=22050) #返回这首歌的time series序列和采样率</span><br><span class="line">S = librosa.core.stft(y,n_fft=1024,hop_length=512,win_length=1024)</span><br><span class="line"># S.shape = (1+n_fft/2,帧数)</span><br><span class="line">X = np.abs(S)</span><br><span class="line">mel_basis = librosa.filters.mel(r,n_fft=1024,n_mels=128) #梅尔滤波器矩阵</span><br><span class="line"># mel_basis.shape=(n_mels,1+n_fft/2)</span><br><span class="line">mel_s = np.dot(mel_basis,X)</span><br><span class="line">np.save(mel_save_path,mel_s)</span><br></pre></td></tr></table></figure><p>reference</p><p>以下这两篇博客将<strong>梅尔频率倒谱系数(MFCC)讲得很清楚</strong>，推荐！求MFCC需要在梅尔频谱的基础上继续取对数再进行变换。这次我只是把梅尔频谱当做神经网络的输入，就先到这里。</p><ol><li><a href="https://blog.csdn.net/zouxy09/article/details/9156785" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/9156785</a></li><li><a href="https://blog.csdn.net/xmdxcsj/article/details/51228791" target="_blank" rel="noopener">https://blog.csdn.net/xmdxcsj/article/details/51228791</a></li><li>CMU的教程也不错：<a href="http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf" target="_blank" rel="noopener">http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.声谱图&lt;/p&gt;
&lt;p&gt;如下图1一段声音信号直观地看起来是时间和能量的关系，在语音识别，音乐信息检索中常常关注的是声音中频率和能量的关系，即声谱图描述的就是频率和能量的关系。所以我们拿到一段音频需要先进行初步的处理，获得它的声谱图。具体的做法则是将声音信号分帧，然后对每一
      
    
    </summary>
    
      <category term="音频信号处理" scheme="http://yoursite.com/categories/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
      <category term="梅尔频谱" scheme="http://yoursite.com/tags/%E6%A2%85%E5%B0%94%E9%A2%91%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>杨奕轩老师</title>
    <link href="http://yoursite.com/2019/01/12/%E6%9D%A8%E5%A5%95%E8%BD%A9%E8%80%81%E5%B8%88/"/>
    <id>http://yoursite.com/2019/01/12/杨奕轩老师/</id>
    <published>2019-01-12T14:39:10.000Z</published>
    <updated>2019-02-18T12:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/与杨奕轩老师的合影.jpg" alt></p><p>在2019年的一月七日，李老师在群里发了一条消息，杨奕轩老师会在一月十日途经上海，到时候会一起吃饭交流！我实在是没有想到能够这么快就见到杨老师，杨老师是台湾中央研究院的老师，他实验室的研究方向是音乐信息检索MIR，杨老师博士期间就开始做音乐情感计算，找到教职后又做了很多音乐情感的工作。</p><p>实验室其他同学可能不太了解杨老师的工作，但是我却再熟悉不过了。我读的第一篇音乐情感计算方面的论文就是杨老师博士期间2008年发在IEEE Transactions on audio，speech，and language processing杂志上的经典论文。这篇经典论文后来非常多次被引用。由于IEEE 杂志每篇论文后面都会有作者的头像和基本信息，杨老师放在那上面的照片是真的帅气，见面之前我猜测：“杨老师2008年应该28岁左右，现在十年过去了杨老师应该是38岁左右吧？”</p><p>一月十号上午十点多老师让我和江益靓师姐去张衡路大门接杨老师，并带杨老师到校园里面逛一逛。师姐不熟悉杨老师，我只和她说了杨老师十年前长得很帅气，但是现在是啥样我也不知道。等了一会儿杨老师就到了，一打开车租车的门，我就惊叹出：哇，还是那么的帅气。杨老师第一次来上海，第一次来复旦。</p><p>他简单的问了我和师姐的基本情况之后，我们直接带他到实验室放下东西。没想到他坐下来直接就和我们开始讨论起来，问我和另外两位师姐目前在做什么工作。他先和研三师姐交流，师姐是做语音增强的，她说杨老师实验室的在SISEC比赛上得到了第三名，杨老师笑着说是第二名，因为一二名得主都是Sony，而且他们现在有一个新的模型已经比Sony第一名的成绩更好，不过还没有发表。然后师姐和杨老师讨论起一些论文，并且杨老师直接推荐了一篇2019年的论文给师姐。紧接着他又问研二的江师姐做了什么工作，师姐和他说她主要在做根据人的嗓音来推荐可以唱的歌曲这个方向，杨老师说这个很有新意啊，接着师姐又说起她昨晚看到的一个医学诊断比赛，是台湾的大学举办的，但是她没有及时的关注到，她想要现在想要他们比赛的数据集。杨老师翻了翻比赛的网站，说其中一位举办者的办公室就在他的隔壁。</p><p>然后杨老师就开始问我我在干嘛，我有点紧张，毕竟杨奕轩老师是音乐情感领域非常厉害的大牛，突然要和大牛面对面交流了。我说起我在关注的2018年ISMIR上两篇关于迁移学习的文章，我说这两篇论文和17年ISMIR那篇最佳论文迁移学习很像，只不过17年那篇用的是“音乐标签”，这里我卡了以下，我没有很快想起“音乐标签”这几个关键词，没想到杨老师马上说：“对，一些music tag”。他肯迪看过这篇论文，我说那你知道这两篇论文吗，这也是韩国人做的工作，只不过18年的论文他们用airtist labels来训练。杨老师说：“他懂”。于是我接着说我接下来还会继续关注迁移学习在音乐情感上的应用。我问杨老师实验室目前在音乐情感方面做什么？他说他有和奥地利一个老师合作，思路也和刚才说的这个迁移学习的想法很像，就是建立一个很大的资料库，收集几十万首歌曲，结合ALLMusic来收集一些情感标签，但是这里面有很多noisy的标签，不管这些，做成一个很大的资料库，利用这个资料库来训练模型，一个可能的方向是在这个数据 库当中在筛选出一些高质量的情感标签出来，与此同时杨老师也提到他们实验室不再做这个方向了，因为这个方向太难做了。<strong>他又说到同样的模型，用来做流派分类也能work的很好，用来做情感分类也很work，从这一点上很受审稿人的刁难，审稿人更希望能够看到一些针对音乐情感本身的研究，一些有新意的研究。他也很意外去年那篇迁移学习的论文能够获得最佳论文，可能是他的论文和实验都做得很完整吧。要想继续在这上面做必须要更多的针对音乐情感本身出发，但是这是很难的</strong>。被杨老师这一席话说得我有点灰心，确实他作为音乐情感计算领域这么厉害的研究者，他都不看好。</p><p>后来吃饭的时候，李老师和杨老师聊了很多大陆有哪些做MIR的研究组，还有前年在苏州举办的ISMIR会议，也讨论了很多关于中国大陆的科研体制和台湾科研体制，也说了上海房价很高。也是在这时，我才知道杨老师只有34岁，他比我猜测的年龄小多了，这也意味着他十年前做出的那篇经典论文还是24岁。和杨老师交流的过程中我们能感觉到他目前还在科研一线，MIR领域的前沿他都follow了，这一点真是太厉害了。</p><p>他说：“他不管有多忙，每周一都会空出来和他实验室的同学group meeting，读论文”。</p><p>我说：“杨老师，那你一定要坚持下去”我之所以这么说是因为目前很多中国大陆的青年学者，在找到教职，或者有行政职务以后就慢慢的不做科研了。这种现象无疑是非常不好的。</p><p>他说：“在他有了孩子以后确实没有以前那么多精力在科研上了，而且现在他和他太太想要第二个孩子。”</p><p>吃饭的时候我还问杨老师知道台大的李宏毅老师吗？他说知道啊，我说在大陆这边很多学生都听过他的深度学习课，他的课讲得非常好，很受学生欢迎。杨老师打趣说:”李宏毅老师是台湾AI界的网红，他实验室很多学生如果不懂深度学习他也会让他们去看李宏毅老师的课。”虽然我可能见不到李宏毅老师了，但是我希望杨老师如果有机会见到李宏毅老师，或许他会提起大陆有很多学生喜欢他讲的课吧。</p><p>吃完饭，李老师让高薇师姐和江师姐送杨老师去徐汇区那边的酒店，我主动提出说我也要去。我不能错过能和杨老师交流的机会。</p><p>在车上，师姐问起：“杨老师参加工作多久了，他说他参加工作已经八年半了，在他博士毕业之后他还去当了一年兵。”令人惊叹！</p><p>后来我们又问起台湾博士毕业需要什么条件</p><p>他说：”只要一篇IEEE transactions就行，但是硕博连读只用了三年半，我远超毕业的要求，我有3篇IEEE transactions“  </p><p>我们：“…”</p><p>杨老师还和我们交流我们的题目是怎么选的，我们说都是老师替我们选的，之后他聊起了他们实验室的学生，他说他招生很严格，招的学生都基本上是要去国外读PHD的，所以学生都很有motivation，他们都掌握了很多的乐理，有个学生本科是学电子工程的，但是选修很多做作曲的课，所以这对研究很有帮助。他们实验室现在有五个学生在做算法作曲。</p><p>他说：“他觉得他对学生很好，junior的学生刚进来会先跟着senior的学生做，senior的学生的题目他会帮助制定，但是也要他们有兴趣做才行”</p><p>后来我们聊起了group meeting和idea，师姐问杨老师会不会给学生想idea，他说他的idea经常一提出来就被学生否定，因为学生都能想到更好的idea，不过这样他都很开心。<strong>他还说在他们的group meeting前他会要求学生先提交要说的东西，如果他觉得他的学生报告的主题知识介绍自己所做的方向，他会建议他的学生换一个报告主题。因为他觉得group meeting不是学生汇报给老师听，要汇报可以单独汇报，而是要学生相互交流，讨论一些有意思的idea。他并不需要学生和他来讲，因为学生讲的对于杨老师来说不是第一次听，而是早就听了好几次了。</strong></p><p>听到这么一说，我和两位师姐面面相觑，因为我们的组会好像就当成向老师报告，而且很多听的同学并不会参与到别人的报告当中。博士师姐说她之前的组会都做得不好，其实大家有何尝不是呢？<strong>听了杨老师这些，我们确实应该rethink我们的组会，因为我们在组会当中没有扮演好自己的角色</strong>。后来的我们还继续讨论一些学术，我们当中无一不深深的折服于杨老师的对整个研究领域的学术观点。</p><p>这篇博客我不能够完整地记录所有重要的对话，可能每个人都会记住自己认为重要的内容吧。从这次简短的交流可以看出：杨奕轩老师是一位MIR领域学术造诣很高的青年研究者，他也是一位管理有方的实验室负责人，他也非常的谦逊，平和。我不觉得他是一位谷歌学术引用已经3000多次的学术研究者，和他的交流过程让我觉得他像是一位博士师兄一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/与杨奕轩老师的合影.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在2019年的一月七日，李老师在群里发了一条消息，杨奕轩老师会在一月十日途经上海，到时候会一起吃饭交流！我实在是没有想到能够这么快就见到杨老师，杨老师是台湾中央研究院的老师，他实验室的
      
    
    </summary>
    
      <category term="学术交流" scheme="http://yoursite.com/categories/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="学术交流" scheme="http://yoursite.com/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>2018年度回顾</title>
    <link href="http://yoursite.com/2018/12/30/2018%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2018/12/30/2018年度回顾/</id>
    <published>2018-12-30T11:17:15.000Z</published>
    <updated>2018-12-30T13:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>忙里偷闲，决定在一年的倒数第二天回顾下自己的2018年。</p><p>本着现代人不喜欢看太长的文字，太长的视频。我决定用自问自答的方式完成这篇年度总结。</p><p>Q代表我向自己提问，A代表我回答自己的提问。</p><ol><li><p>Q：2018年是你人生进程中相当重要的一年，有哪些新的变化和感受？</p><p>A：这一年里我结束了写满失望的本科生涯，离开了生活了22年的湖南，来到了一直想来的上海，到fdu继续自己的学生生涯。在后半年熬夜的天数暴增。同样在这一年我终于萌生出对计算机的喜爱，严格来说这一年开始写下第一行程序，想要学习一些新奇的计算机技术。离开了家乡才知道原来自己的普通话是多么的糟糕！这一年终于开始写博客，在未来会继续维护两个博客。</p></li><li><p>Q：2018年最有价值的一个选择？</p><p>A：很早就揣着要环游世界的想法，然而那只是一个想法，从来没有认真的实现它过。所以今年的最佳选择是2018年九月收到复旦大学登山协会一条关于穿越炉西峡的推送，我只用了几分钟考虑就决定参加。这是一个美好又意义深远开始，后来我还和华师大萤火虫去了温州雁荡山，寒假里我还要去宝岛台湾完成环岛活动。或许那一晚会是我完成环游世界梦想的开端。</p></li><li><p>Q：2018年最遗憾的一件事？</p><p>A：和一个认识多年的朋友闹掰了，近一年没有说过话了。我犯过的错误很多，这是其中一个。</p></li><li><p>Q：2018年看过的最佳电影？</p><p>A：从我全年线下和线上看过的四十多部各种题材的电影候选里。《爱在黎明破晓时》《爱在日落黄昏时》是我心中的最佳电影。电影里对爱情和性的谈论真是impressive，我觉得没有谈过恋爱的人恋爱必看，还没有结婚的结婚前必看，啊，已经结婚了？还是必看。</p></li><li><p>Q：2018年玩过的最佳游戏？</p><p>A：今年花了不少钱在购买游戏，游戏设备上。手上目前屯了(八方旅人，黑暗之魂)没玩，真正完整玩完了的游戏只有《塞尔达传说·旷野之息》，《返校》，《死亡细胞》，恕我实在是没有时间玩游戏。毫无疑问，《旷野之息》是我心中最佳游戏，在我做本科毕设的时候我花了大概85小时在旷野之息上。谁知道这是我时间最富裕的一段时间了，后来我就再也没有充足时间，能够全身心地去鉴赏一款游戏了。在我心中具有优秀设计的游戏就像艺术品一样。</p></li><li><p>Q：2018年看过的最佳书籍？</p><p>A：说来惭愧，这应该是我做得最不好的事情了。在阅读方面，读的书籍实在是太少太少了。如果愣是要少中选优的话是《创新公司皮克斯的启示》。理由是：它讲了一家公司为什么能成为一家创新公司，虽然我没有公司，不过我从里面学到如何和聪明人相处？今年在阅读方面我简直就是个loser，然而我在知乎上却读了6600万字，阅读的时间都去哪了？呵呵，花在知乎上了。真是少刷知乎多读书的反面典型。</p></li><li><p>Q：明白的最深刻的一个道理？</p><p>A：很多事情，我们只能看到表面，表面上看起来很酷，实际上真正做起来很难。就像人工智能看起来很酷，真正从事起来发现这是一堆数学，这个工作一点都不酷；就像我们玩到一个优秀游戏后，心里自然而然就有一种冲动，我为什么不能成为一个游戏设计者，然而当看到游戏开发背后的故事时，会发现游戏开发那一点都不酷，相当的无聊。</p></li><li><p>Q：新年有什么愿望？</p><p>A：希望父母身体健康，希望新的一年里自己的英语听说读写水平有好的进步。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忙里偷闲，决定在一年的倒数第二天回顾下自己的2018年。&lt;/p&gt;
&lt;p&gt;本着现代人不喜欢看太长的文字，太长的视频。我决定用自问自答的方式完成这篇年度总结。&lt;/p&gt;
&lt;p&gt;Q代表我向自己提问，A代表我回答自己的提问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Q：2018年是你人生进程
      
    
    </summary>
    
      <category term="只关心自己" scheme="http://yoursite.com/categories/%E5%8F%AA%E5%85%B3%E5%BF%83%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="年度总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>近窥MIREX-Like数据集和MIREX 08数据集</title>
    <link href="http://yoursite.com/2018/12/26/%E8%BF%91%E7%AA%A5MIREX-Like%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8CMIREX%2008%20%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/26/近窥MIREX-Like数据集和MIREX 08 数据集/</id>
    <published>2018-12-26T12:04:53.000Z</published>
    <updated>2019-03-19T02:42:38.096Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章翻译自<a href="https://musicinformationretrieval.wordpress.com/2017/03/16/take-a-closure-look-at-the-dataset/" target="_blank" rel="noopener">Student blog for the MIR course, Master in Sound and Music Computing, Universitat Pompeu Fabra (2017)</a>。我觉得还挺有意思的就翻译了一下，有些我拿不准的地方我就引用了原文的词语。这两个数据集还挺有意思。</p><hr><p>MIREX-Like数据集第一次在10th International Symposium on Computer Music Multidisciplinary Research-CMMR‘2013会议上公布出来[1]，由于一直缺乏标准的，标注质量好的音乐情感数据集，研究者们在绝大部分音乐情感学术研究里都使用自己制作的数据集，这导致他们取得的结果不能够在同一个数据集上进行比较。尽管每年MIREX 情感识别竞赛有mirex mood classification数据集，但是这个数据集不是公开的。新的MIREX-Like数据集 包含了903首音乐样本，同样这也是一个用于音乐情感研究的多模态数据集，它还囊括了歌词和每首歌的MIDI，但是它只有196首歌曲的MIDI。</p><ul><li><strong>数据集的获取</strong></li></ul><p>MIREX-Like数据集的制作者从ALLMusic收集数据，ALLMusic上的音乐标注都是由专业人员标注，而不是Last.FM的数据都是由音乐社区中的音乐听众标注的。所以ALLMusic的标注可能更加可靠。制作者收集标注时使用的情感标签和MIREX 08数据集是一致的。如果某首音乐的标签属于多个类别，那么他们会偏向选择标签数量更多的情感类别。比如：一首歌有’passionate‘(Cluster1)，‘confident’(Cluster1),’humorous‘(Cluster4)，那么这首歌会被分类到Cluster1。MIREX-Like数据集总共903首音乐歌曲，在五个类别上的数量分布是很平衡的，其中18.8%cluster 1, 18.2% cluster 2, 23.8% cluster 3, 21.2% cluster 4 and 18.1% cluster 5。</p><ul><li><strong>数据特征</strong></li></ul><p>即便标签都是由专业人员标注，这些标签在五个类别的的划分仍然不是很合理。尽管我们不能直接比较两个数据集，因为我们没有办法听到MIREX 08数据集的音乐文件。通过一个简单的验证步骤，我们能够得到结论：MIREX-Like数据集的歧义性(原文用的是ambiguity)比MIREX 08高。</p><p>的确，拿我们论文[2]当中用过的特征，使用SVM在MIREX-Like数据集分类，accuracy只有区区的40%，相比MIREX 08上的大多数结果在60%左右，这是一个很低的结果。MIREX-Like数据集的作者也在该文章[1]中使用了他们的分类方法，用SVM分类也只有44.9%的分类准确率。然而，他们使用一些旋律相关特征时，准确率可以提高到52.8%。他们基于旋律自动提取系统提取的98个旋律相关特征，尽管这些特征的用途并不相同。</p><ul><li><strong>类别分析</strong></li></ul><p>就在语义空间表示而言，用来讨论分析情感分类方法使用的不同情感分类类别是非常重要的，因为它或许能够解释这些分类算法的混乱。文献[4]分析了不同情感空间表示的intra-cluster similarity(类内相似性)和inter-cluster similarity(类间相似性)。intra-cluster similarity衡量的是<strong>community-based表征和expert-based表征(如Russell情感表示[5])之间的一致性</strong></p><p>就MIREX使用的五类情感类别而言，具有最低intra-cluster similarity的是cluster2(sweet, good natured,cheerful, rollicking, amiable, fun)，也许这么普通大众和专家意见如此一致的原因是这一类都是一些使人快乐的音乐。然而如果使用的形容词如果不是如此普通寻常的词语的话，这样做也许会降低这个值。总之MIREX 的情感表示的intra-cluster similarity相当高。</p><p>inter-cluster similarity，它在音乐情感分类方法中非常重要，衡量的是不同的情感类别之间的独立性(原文用的how separable the cluster are)，它的计算方法是取一个类别质心(类别内所有点的平均值)到其他所有类别质心之间的余弦距离，文献[4]给出了MIREX clusters类别的inter-cluster similarity混淆矩阵(confusion matrix)。这个矩阵告诉我们，cluster1和cluster5的值最低，表示这两个情感类别相当相似。</p><p>这些发现和MIREX竞赛上的结果是一致的，这两类的混淆性也很显著(见文献[6]），文献6也给出了cluster2和cluster4的混淆性(confusion)。</p><p>此外观察到的最独立的cluster5和cluster2，在MIREX 分类结果上也具有比较小的混淆性(confusion)[4]。</p><p><img src="images/Mirex-like数据集的插图.jpg" alt></p><p>Laurier表示MIREX的情感类别表示，还有在他研究里的其他情感表示既有优点但是也有局限性，观察到的不同MIREX cluster之间的混淆性和相似性验证了先前分析的结果。</p><p>从Lauriers分析中的计算结果来看，他认为MIREX的情感表示目前不是一个最优的表示方法。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] R. Panda, R. Malheiro, B. Rocha, A. Oliveira, and R. P. Paiva, “Multi-Modal Music Emotion Recognition: A New Dataset, Methodology and Comparative Analysis” 10th International Symposium on Computer Music Multidisciplinary Research – CMMR’2013.</p><p>[2] Laurier, Cyril, et al. “Audio music mood classification using support vector machine.” <em>MIREX task on Audio Mood Classification</em> (2007): 2-4.</p><p>[3] Salamon, Justin, Bruno Rocha, and Emilia Gómez. “Musical genre classification using melody features extracted from polyphonic music signals.” <em>Acoustics, Speech and Signal Processing (ICASSP), 2012 IEEE International Conference on</em>. IEEE, 2012.</p><p>[4] Laurier, Cyril. <em>Automatic classification of musical mood by content based analysis</em>. Universitat Pompeu Fabra, 2011.</p><p>[5] Ressel, J. A. “A circumplex model of affect.” <em>J. Personality and Social Psychology</em> 39 (1980): 1161-78.</p><p>[6] Downie, X. H. J. S., Cyril Laurier, and M. B. A. F. Ehmann. “The 2007 MIREX audio mood classification task: Lessons learned.” <em>Proc. 9th Int. Conf. Music Inf. Retrieval</em>. 2008.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://musicinformationretrieval.wordpress.com/2017/03/16/take-a-closure-look-at-the-dataset/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Dataset" scheme="http://yoursite.com/categories/Dataset/"/>
    
    
      <category term="Music Emotion Rearch" scheme="http://yoursite.com/tags/Music-Emotion-Rearch/"/>
    
      <category term="文章翻译" scheme="http://yoursite.com/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
