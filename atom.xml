<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王磊的百草园</title>
  
  <subtitle>Life Is Short</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-25T06:41:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wanglei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题（一）</title>
    <link href="http://yoursite.com/2019/02/25/LeetCode%E5%88%B7%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/25/LeetCode刷题（一）/</id>
    <published>2019-02-25T06:38:52.000Z</published>
    <updated>2019-02-25T06:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode1.两数之和(2019.2.17日)</p><p>直接思路：暴力求解</p><p>从list的两端开始遍历，一直遍历到两端指向同一个元素，如果遍历过程中找到了两个元素之和等于target，返回索引，没有则将首端的指针指向下一个元素。显然算法复杂度为O(n2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        length = len(nums)</span><br><span class="line">        for i in range(length-1):</span><br><span class="line">            for j in range(length-1,i,-1):</span><br><span class="line">                   if nums[i] +nums[j] == target:</span><br><span class="line">                       return [i,j]</span><br></pre></td></tr></table></figure><p>改进算法：哈希表</p><p>将每个值的索引存入哈希表中，遍历list的每一元素value，求出target-value值，用这个值去哈希表中寻找对应的索引，找到即返回。算法复杂度为O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        for i,value in enumerate(nums):</span><br><span class="line">            tmp = target - value</span><br><span class="line">            if tmp in hashmap:</span><br><span class="line">                return [i,hashmap[tmp]]</span><br><span class="line">            hashmap[value] = i</span><br></pre></td></tr></table></figure><p>LeetCode7.整数反转</p><p>思路：获得每个位上的数字，具体可以通过%10操作获得个位数字压入队列中，再整除10，再%10获得十位上的数字，直到最后一位，将最后一位压入队列中。如果整数小于0，预先把符号保存下来，正数就不需要管。其次就是120,1230这种最后以0结尾的数，在反转后的数字第一位不能是0，所以我们需要从队列第一个不为0的数字开始恢复，依次将队列里面的数字出队，乘以10，再加上下一个出队数字，再乘以10。最后还要检查反转后的数字是否溢出！有个测试样例1534236469反转后的9646327351就溢出了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        tmp = []</span><br><span class="line">        flag1 = 1</span><br><span class="line">        if x &lt; 0:</span><br><span class="line">            x *= -1</span><br><span class="line">            flag1 = -1</span><br><span class="line">        if -10&lt;x&lt;10:</span><br><span class="line">            return x*flag1</span><br><span class="line">        flag = 1</span><br><span class="line">        while(flag):</span><br><span class="line">            count = x % 10</span><br><span class="line">            tmp.append(count)</span><br><span class="line">            x = x // 10</span><br><span class="line">            if x &lt; 10:</span><br><span class="line">                flag = 0</span><br><span class="line">                tmp.append(x)</span><br><span class="line">        newx,counts = (0,0)</span><br><span class="line">        for i in range(len(tmp)):</span><br><span class="line">            if tmp[i] != 0:</span><br><span class="line">                counts = i</span><br><span class="line">                break</span><br><span class="line">        for j in range(counts, len(tmp)):</span><br><span class="line">            newx += tmp[j]</span><br><span class="line">            if j != len(tmp)-1:</span><br><span class="line">                newx *= 10</span><br><span class="line">        if -2**31&lt;newx*flag1&lt;2**31 -1:</span><br><span class="line">            return newx*flag1</span><br><span class="line">        else:</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure><p>LeetCode9.回文数</p><p>思路：这其实是一个字符串反转的问题，没什么好说的。python中字符串反转的方法还有递归的思路，用栈，用字符串的分片操作，还有reversed函数一共五种，<a href="https://www.geeksforgeeks.org/reverse-string-python-5-different-ways/" target="_blank" rel="noopener">具体参考这个网址</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        x_str = str(x)</span><br><span class="line">        y_str = &quot;&quot;</span><br><span class="line">        for i in x_str:</span><br><span class="line">            y_str = i + y_str</span><br><span class="line">        count = 0</span><br><span class="line">        for i in range(len(x_str)):</span><br><span class="line">            if x_str[i] == y_str[i]:</span><br><span class="line">                count += 1</span><br><span class="line">        if count == len(x_str):</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><p>LeetCode13.罗马数转换成整数</p><p>思路：这个问题我们可以直接将罗马数字和整数之间转换关系用字典表示，然后再判断”IV”,”IX”,”XL”,”XC”,”CD”,”CM”这六种特殊情况。罗马数字转换到整数直接将每个字符串按位相加就可以了。</p><p>Tips：我的解法有个小问题就是需要注意判断那六种特殊情况是，需要加上”索引i大于0”条件,不加的话，碰到”XXVII“这类会输出25而不是27，因为第一个”X“会被判定为8而不是10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        index_dic=&#123;&apos;I&apos;:1,&apos;V&apos;:5,&apos;X&apos;:10,&apos;L&apos;:50,&apos;C&apos;:100,&apos;D&apos;:500,&apos;M&apos;:1000&#125;</span><br><span class="line">        value_int=0</span><br><span class="line">        for i,value in enumerate(s):</span><br><span class="line">            if s[i] == &apos;V&apos; and s[i-1] == &apos;I&apos; and i &gt; 0:</span><br><span class="line">                value_int += 3</span><br><span class="line">            elif s[i] == &apos;X&apos; and s[i-1] == &apos;I&apos; and i &gt; 0:</span><br><span class="line">                value_int += 8</span><br><span class="line">            elif s[i] == &apos;L&apos; and s[i-1] == &apos;X&apos;and i &gt; 0:</span><br><span class="line">                value_int += 30</span><br><span class="line">            elif s[i] == &apos;C&apos; and s[i-1] == &apos;X&apos;and i &gt; 0:</span><br><span class="line">                value_int += 80</span><br><span class="line">            elif s[i] == &apos;D&apos; and s[i-1] == &apos;C&apos;and i &gt; 0:</span><br><span class="line">                value_int += 300</span><br><span class="line">            elif s[i] == &apos;M&apos; and s[i-1] == &apos;C&apos;and i &gt; 0:</span><br><span class="line">                value_int += 800</span><br><span class="line">            else:</span><br><span class="line">                value_int += index_dic[s[i]]</span><br><span class="line">        return value_int</span><br></pre></td></tr></table></figure><p>LeetCode14.最长公共前缀</p><p>算法：我的算法解这道题基于一个前提：<strong>最长的公共前缀的长度必定小于等于字符串数组中最短的那个字符串</strong>。所以先用字符串排序取得最短长度的字符串a。按顺序取出a的每一位，与字符串数组剩下的每一个字符串同样的位置比较是否相等，相等则将这一位存储到list中，继续比较，如果不相等就不需要继续比较了。此时判断list中有0个字符还是大于0个字符，一个字符就返回”“（第一个字符就不相等），多个字符就返回除了当前字符以外别的字符(因为当前字符不相等)。如果最短字符串的所有字符都比较完毕，那么久输出这个最短字符即可。</p><p>注意需要判断[]和[“”]这两种情况。需要进行特判。我的这个算法在时间复杂度上是最优算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: &apos;List[str]&apos;) -&gt; &apos;str&apos;:</span><br><span class="line">        if len(strs) == 0:</span><br><span class="line">            str = &quot;&quot;</span><br><span class="line">            return str</span><br><span class="line">        strs.sort(key=len)</span><br><span class="line">        short_list = []</span><br><span class="line">        if strs[0] == &quot;&quot;:</span><br><span class="line">            str = &quot;&quot;</span><br><span class="line">            return str</span><br><span class="line">        for i in range(len(strs[0])):</span><br><span class="line">            tmp=strs[0][i]</span><br><span class="line">            short_list.append(tmp)</span><br><span class="line">            flag = 0</span><br><span class="line">            for j in range(len(strs)):</span><br><span class="line">                if strs[j][i] != tmp:</span><br><span class="line">                    flag = 1</span><br><span class="line">            if flag and len(short_list)==0:</span><br><span class="line">                str = &quot;&quot;</span><br><span class="line">                return str</span><br><span class="line">            elif flag and len(short_list) &gt; 0:</span><br><span class="line">                str = &quot;&quot;.join(short_list[:-1])</span><br><span class="line">                return str</span><br><span class="line">        if i == len(strs[0])-1:</span><br><span class="line">            str = &quot;&quot;.join(short_list)</span><br><span class="line">            return str</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LeetCode1.两数之和(2019.2.17日)&lt;/p&gt;
&lt;p&gt;直接思路：暴力求解&lt;/p&gt;
&lt;p&gt;从list的两端开始遍历，一直遍历到两端指向同一个元素，如果遍历过程中找到了两个元素之和等于target，返回索引，没有则将首端的指针指向下一个元素。显然算法复杂度为O(n
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>理解Python中的defaultdictt</title>
    <link href="http://yoursite.com/2019/02/25/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84defaultdict/"/>
    <id>http://yoursite.com/2019/02/25/理解Python中的defaultdict/</id>
    <published>2019-02-25T06:35:22.000Z</published>
    <updated>2019-02-25T06:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，如果访问字典中不存在的键时会引发KeyError的异常。但是如果字典中的键如果能够有默认的值有时候是非常方便的。比如以下的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for i in strings:</span><br><span class="line">counts[i] += 1</span><br></pre></td></tr></table></figure><p>以上这个例子是用来统计单词出现的次数，将单词作为count中的键，单词每出现一次就加1.事实上这段代码是会抛出KeyError的。</p><p>有以下几个办法能够处理这个问题。</p><h5 id="使用判断语句检查"><a href="#使用判断语句检查" class="headerlink" title="使用判断语句检查"></a>使用判断语句检查</h5><hr><p>我们可以在每次取得单词时候，检查这个单词是否在字典中有默认值，没有就赋一个默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for i in strings:</span><br><span class="line">if i not in count:</span><br><span class="line">counts[i] = 0</span><br><span class="line">counts[i] += 1</span><br></pre></td></tr></table></figure><h5 id="dict-setdefault-方法"><a href="#dict-setdefault-方法" class="headerlink" title="dict.setdefault()方法"></a>dict.setdefault()方法</h5><hr><p>我们也可以使用dict.setdefault()方法来设置默认值：这个方法结构两个参数，一个是键的名称，另一个是默认值。如果键已经存在字典中就返回它的值，如果没有就将默认值保存并且返回该默认值。用dict.setdefault()重写上面的例子</p><blockquote><p><code>setdefault</code>(<em>key</em>[, <em>default</em>])</p><p>If <em>key</em> is in the dictionary, return its value. If not, insert <em>key</em> with a value of <em>default</em> and return <em>default</em>. <em>default</em> defaults to <code>None</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for i in strings:</span><br><span class="line">counts.setdefault(i,0)</span><br><span class="line">counts[i] += 1</span><br></pre></td></tr></table></figure><p>下面这种方法就是我们本篇博客的主角collections.defaultdict类</p><h5 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h5><hr><blockquote><p><em>class</em> <code>collections.`</code>defaultdict`([<em>default_factory</em>[, <em>…</em>]])</p></blockquote><p>defaultdict类返回一个类似于的字典对象，第一个参数给default_factory属性赋值，其它的参数都传递给dict构造器。<strong>通俗来说就是defaultdict类的初始化函数接收一个类型作为参数，当访问的键不存在，实例化一个值作为默认值</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(list)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;lei&apos;]</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;lei&apos;: []&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;wang&apos;].append(22)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;lei&apos;: [], &apos;wang&apos;: [22]&#125;)</span><br></pre></td></tr></table></figure><p>但是这种使用仅限于直接通过访问字典的键dict[key]或者dict.__getitem__()这两种方式，如下面的例子，其它的使用都不行，具体原因稍后介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;xu&apos; in dd</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; dd.pop(&apos;xu&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    dd.pop(&apos;xu&apos;)</span><br><span class="line">KeyError: &apos;xu&apos;</span><br><span class="line">&gt;&gt;&gt; dd.get(&apos;xu&apos;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;xu&apos;]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>该类除了接收类型名称来作为初始化函数的参数，还可以使用任何不带参数的可调用函数作为参数，函数的返回结果就作为默认值，这样可以使得默认值的取值更加灵活。下面的例子是介绍这种用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; def one():</span><br><span class="line">return 1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(one)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;function one at 0x1101ff2f0&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;lei&apos;]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;function one at 0x1101ff2f0&gt;, &#123;&apos;lei&apos;: 1&#125;)</span><br></pre></td></tr></table></figure><p>同样我们也可以使用匿名函数lambda来作为参数，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">strings =&#123;&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&apos;,&apos;puppy&apos;,&apos;wesel&apos;,&apos;puppy&apos;,&apos;kitten&apos;,&apos;puppy&#125;</span><br><span class="line">counts = defaultdict(lambda: 0)</span><br><span class="line">for i in strings:</span><br><span class="line">counts[i] +=1</span><br></pre></td></tr></table></figure><p>为什么defaultdict类可以实现这样的用法呢，因为它支持<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">__missing__()方法</a>。</p><blockquote><p><em>class</em> <code>collections.`</code>defaultdict`([<em>default_factory</em>[, <em>…</em>]])</p><p><code>__missing__</code>(<em>key</em>)</p><p>If the <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> attribute is <code>None</code>, this raises a <a href="https://docs.python.org/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> exception with the <em>key</em> as argument.</p><p>If <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> is not <code>None</code>, it is called without arguments to provide a default value for the given <em>key</em>, this value is inserted in the dictionary for the <em>key</em>, and returned.</p><p>If calling <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a> raises an exception this exception is propagated unchanged.</p><p>This method is called by the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> method of the <a href="https://docs.python.org/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> class when the requested key is not found; whatever it returns or raises is then returned or raised by <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>.</p><p>Note that <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.__missing__" target="_blank" rel="noopener"><code>__missing__()</code></a> is <em>not</em> called for any operations besides <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>. This means that <code>get()</code> will, like normal dictionaries, return <code>None</code> as a default rather than using<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" target="_blank" rel="noopener"><code>default_factory</code></a></p></blockquote><p> 从第二句我们可以看到如果default_factory不是None,调用时会给给定的key一个默认值，这个默认值会保存在key对应的之中，并且被返回。第四句说明这个方法只会被 __getitem__()方法调用,dict[key]这种形式实际上是__getitem__方法的简化形式。</p><p>当__getitem__()方法访问一个不存在的键时会调用__missing__()方法获得默认的值，将该键添加到字典中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(defaultdict.__missing__.__doc__)</span><br><span class="line">__missing__(key) # Called by __getitem__ for missing key; pseudo-code:</span><br><span class="line">  if self.default_factory is None: raise KeyError((key,))</span><br><span class="line">  self[key] = value = self.default_factory()</span><br><span class="line">  return value</span><br></pre></td></tr></table></figure><h5 id="实现一个defaultdict功能"><a href="#实现一个defaultdict功能" class="headerlink" title="实现一个defaultdict功能"></a>实现一个defaultdict功能</h5><hr><p>在<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" target="_blank" rel="noopener">”dict“</a>python文档中还介绍，如果dict的子类实现了__missing__方法，当访问不存在的键时，dict[key]会调用__missing__（）方法来获得默认值。下面我们可以进一步实验，定义一个dict的子类Missing并且实现__missing__()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Missing(dict):</span><br><span class="line">def __missing__(self,key):</span><br><span class="line">return &apos;missing&apos;</span><br><span class="line">&gt;&gt;&gt; d = Missing()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;lei&apos;]</span><br><span class="line">&apos;missing&apos;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回结果表明__missing__()方法确实发挥了作用，但是key没有添加到字典当中去，我们再修改一下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class defaultdict(dict):</span><br><span class="line">def __missing__(self,key):</span><br><span class="line">self[key] = &apos;wanglei&apos;</span><br><span class="line">return &apos;wanglei&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dd=defaultdict()</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; dd[&apos;foo&apos;]</span><br><span class="line">&apos;wanglei&apos;</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">&#123;&apos;foo&apos;: &apos;wanglei&apos;&#125;</span><br></pre></td></tr></table></figure><h5 id="在旧的Python版本中实现defaultdict功能"><a href="#在旧的Python版本中实现defaultdict功能" class="headerlink" title="在旧的Python版本中实现defaultdict功能"></a>在旧的Python版本中实现defaultdict功能</h5><hr><p>本来这个我不想写了，但是我觉得有必要综合一下上面所说的。defaultdict类是在Python2.5中加入进来的，但是我们可以实现一个兼容defaultdict的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class defaultdict(dict):</span><br><span class="line">    # 首先当 __getitem__()方法访问键失败的时候，调用__missing__方法。</span><br><span class="line">def __getitem__(self,key):</span><br><span class="line">try:</span><br><span class="line">return dict.__getitem__(self,key)</span><br><span class="line">except KeyError:</span><br><span class="line">return self.__missing__(key)</span><br><span class="line"># 实现__missing__方法来给设置默认值</span><br><span class="line">def __missing__(key):</span><br><span class="line">self[key] =value = self.default_factory()</span><br><span class="line">return value</span><br></pre></td></tr></table></figure><p>然后defaultdict类的初始化函数__init__()需要接收类型或者可调用函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class defaultdict(dict):</span><br><span class="line">    def __init__(self,default_factory=None,*a,**kwag):</span><br><span class="line">    dict.__init__(self,*a,**kwag)</span><br><span class="line">    self.default_factory = default_factory</span><br><span class="line">    # 首先当 __getitem__()方法访问键失败的时候，调用__missing__方法。</span><br><span class="line">def __getitem__(self,key):</span><br><span class="line">try:</span><br><span class="line">return dict.__getitem__(self,key)</span><br><span class="line">except KeyError:</span><br><span class="line">return self.__missing__(key)</span><br><span class="line"># 实现__missing__方法来给设置默认值</span><br><span class="line">def __missing__(key):</span><br><span class="line">self[key] =value = self.default_factory()</span><br><span class="line">return value</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>本文主要参考了这篇</p><p><a href="http://kodango.com/understand-defaultdict-in-python" target="_blank" rel="noopener">http://kodango.com/understand-defaultdict-in-python</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python中，如果访问字典中不存在的键时会引发KeyError的异常。但是如果字典中的键如果能够有默认的值有时候是非常方便的。比如以下的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="Python学习" scheme="http://yoursite.com/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="defaultdict" scheme="http://yoursite.com/tags/defaultdict/"/>
    
  </entry>
  
  <entry>
    <title>如何提取出一首歌曲的梅尔频谱</title>
    <link href="http://yoursite.com/2019/02/18/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E5%87%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E6%9B%B2%E7%9A%84%E6%A2%85%E5%B0%94%E9%A2%91%E8%B0%B1/"/>
    <id>http://yoursite.com/2019/02/18/如何提取出一首歌曲的梅尔频谱/</id>
    <published>2019-02-18T12:17:26.000Z</published>
    <updated>2019-02-18T12:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.声谱图</p><p>如下图1一段声音信号直观地看起来是时间和能量的关系，在语音识别，音乐信息检索中常常关注的是声音中频率和能量的关系，即声谱图描述的就是频率和能量的关系。所以我们拿到一段音频需要先进行初步的处理，获得它的声谱图。具体的做法则是将声音信号分帧，然后对每一帧都用短时傅里叶变换处理，当然进行傅里叶变换之前还预先需要对声音信号进行预加重，加窗。</p><p><img src="/images/声波图.jpg" alt></p><p>2.梅尔频谱</p><p>由于人耳对声音的感知不是线性的，人耳对声音的低频比对声音的高频更加敏感。所以常常需要将线性频谱转换到非线性的梅尔频谱。普通频率转换到梅尔频率的公式是<br>$$<br>m=2595log_{10}(1+\frac f{700})<br>$$<br>我们将一组频域信号通过梅尔滤波器组就可以获得梅尔频谱。</p><p>总结一下获得梅尔频谱的大概流程：首先对时域信号进行傅里叶变换转换到频域，然后再利用梅尔频率刻度的滤波器组对应频域信号进行处理，就可以得到梅尔频谱。这个流程可以使用<a href="https://librosa.github.io/librosa/index.html" target="_blank" rel="noopener">librosa库</a>来完成，下面就是相应的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import librosa</span><br><span class="line">import numpy as np</span><br><span class="line">def get_melcepstrum(audio_path,mel_save_path):</span><br><span class="line">y, sr = librosa.load(aduio_path,sr=22050) #返回这首歌的time series序列和采样率</span><br><span class="line">S = librosa.core.stft(y,n_fft=1024,hop_length=512,win_length=1024)</span><br><span class="line"># S.shape = (1+n_fft/2,帧数)</span><br><span class="line">X = np.abs(S)</span><br><span class="line">mel_basis = librosa.filters.mel(r,n_fft=1024,n_mels=128) #梅尔滤波器矩阵</span><br><span class="line"># mel_basis.shape=(n_mels,1+n_fft/2)</span><br><span class="line">mel_s = np.dot(mel_basis,X)</span><br><span class="line">np.save(mel_save_path,mel_s)</span><br></pre></td></tr></table></figure><p>reference</p><p>以下这两篇博客将<strong>梅尔频率倒谱系数(MFCC)讲得很清楚</strong>，推荐！求MFCC需要在梅尔频谱的基础上继续取对数再进行变换。这次我只是把梅尔频谱当做神经网络的输入，就先到这里。</p><ol><li><a href="https://blog.csdn.net/zouxy09/article/details/9156785" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/9156785</a></li><li><a href="https://blog.csdn.net/xmdxcsj/article/details/51228791" target="_blank" rel="noopener">https://blog.csdn.net/xmdxcsj/article/details/51228791</a></li><li>CMU的教程也不错：<a href="http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf" target="_blank" rel="noopener">http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.声谱图&lt;/p&gt;
&lt;p&gt;如下图1一段声音信号直观地看起来是时间和能量的关系，在语音识别，音乐信息检索中常常关注的是声音中频率和能量的关系，即声谱图描述的就是频率和能量的关系。所以我们拿到一段音频需要先进行初步的处理，获得它的声谱图。具体的做法则是将声音信号分帧，然后对每一
      
    
    </summary>
    
      <category term="音频信号处理" scheme="http://yoursite.com/categories/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
      <category term="梅尔频谱" scheme="http://yoursite.com/tags/%E6%A2%85%E5%B0%94%E9%A2%91%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>杨奕轩老师</title>
    <link href="http://yoursite.com/2019/01/12/%E6%9D%A8%E5%A5%95%E8%BD%A9%E8%80%81%E5%B8%88/"/>
    <id>http://yoursite.com/2019/01/12/杨奕轩老师/</id>
    <published>2019-01-12T14:39:10.000Z</published>
    <updated>2019-02-18T12:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/与杨奕轩老师的合影.jpg" alt></p><p>在2019年的一月七日，李老师在群里发了一条消息，杨奕轩老师会在一月十日途经上海，到时候会一起吃饭交流！我实在是没有想到能够这么快就见到杨老师，杨老师是台湾中央研究院的老师，他实验室的研究方向是音乐信息检索MIR，杨老师博士期间就开始做音乐情感计算，找到教职后又做了很多音乐情感的工作。</p><p>实验室其他同学可能不太了解杨老师的工作，但是我却再熟悉不过了。我读的第一篇音乐情感计算方面的论文就是杨老师博士期间2008年发在IEEE Transactions on audio，speech，and language processing杂志上的经典论文。这篇经典论文后来非常多次被引用。由于IEEE 杂志每篇论文后面都会有作者的头像和基本信息，杨老师放在那上面的照片是真的帅气，见面之前我猜测：“杨老师2008年应该28岁左右，现在十年过去了杨老师应该是38岁左右吧？”</p><p>一月十号上午十点多老师让我和江益靓师姐去张衡路大门接杨老师，并带杨老师到校园里面逛一逛。师姐不熟悉杨老师，我只和她说了杨老师十年前长得很帅气，但是现在是啥样我也不知道。等了一会儿杨老师就到了，一打开车租车的门，我就惊叹出：哇，还是那么的帅气。杨老师第一次来上海，第一次来复旦。</p><p>他简单的问了我和师姐的基本情况之后，我们直接带他到实验室放下东西。没想到他坐下来直接就和我们开始讨论起来，问我和另外两位师姐目前在做什么工作。他先和研三师姐交流，师姐是做语音增强的，她说杨老师实验室的在SISEC比赛上得到了第三名，杨老师笑着说是第二名，因为一二名得主都是Sony，而且他们现在有一个新的模型已经比Sony第一名的成绩更好，不过还没有发表。然后师姐和杨老师讨论起一些论文，并且杨老师直接推荐了一篇2019年的论文给师姐。紧接着他又问研二的江师姐做了什么工作，师姐和他说她主要在做根据人的嗓音来推荐可以唱的歌曲这个方向，杨老师说这个很有新意啊，接着师姐又说起她昨晚看到的一个医学诊断比赛，是台湾的大学举办的，但是她没有及时的关注到，她想要现在想要他们比赛的数据集。杨老师翻了翻比赛的网站，说其中一位举办者的办公室就在他的隔壁。</p><p>然后杨老师就开始问我我在干嘛，我有点紧张，毕竟杨奕轩老师是音乐情感领域非常厉害的大牛，突然要和大牛面对面交流了。我说起我在关注的2018年ISMIR上两篇关于迁移学习的文章，我说这两篇论文和17年ISMIR那篇最佳论文迁移学习很像，只不过17年那篇用的是“音乐标签”，这里我卡了以下，我没有很快想起“音乐标签”这几个关键词，没想到杨老师马上说：“对，一些music tag”。他肯迪看过这篇论文，我说那你知道这两篇论文吗，这也是韩国人做的工作，只不过18年的论文他们用airtist labels来训练。杨老师说：“他懂”。于是我接着说我接下来还会继续关注迁移学习在音乐情感上的应用。我问杨老师实验室目前在音乐情感方面做什么？他说他有和奥地利一个老师合作，思路也和刚才说的这个迁移学习的想法很像，就是建立一个很大的资料库，收集几十万首歌曲，结合ALLMusic来收集一些情感标签，但是这里面有很多noisy的标签，不管这些，做成一个很大的资料库，利用这个资料库来训练模型，一个可能的方向是在这个数据 库当中在筛选出一些高质量的情感标签出来，与此同时杨老师也提到他们实验室不再做这个方向了，因为这个方向太难做了。<strong>他又说到同样的模型，用来做流派分类也能work的很好，用来做情感分类也很work，从这一点上很受审稿人的刁难，审稿人更希望能够看到一些针对音乐情感本身的研究，一些有新意的研究。他也很意外去年那篇迁移学习的论文能够获得最佳论文，可能是他的论文和实验都做得很完整吧。要想继续在这上面做必须要更多的针对音乐情感本身出发，但是这是很难的</strong>。被杨老师这一席话说得我有点灰心，确实他作为音乐情感计算领域这么厉害的研究者，他都不看好。</p><p>后来吃饭的时候，李老师和杨老师聊了很多大陆有哪些做MIR的研究组，还有前年在苏州举办的ISMIR会议，也讨论了很多关于中国大陆的科研体制和台湾科研体制，也说了上海房价很高。也是在这时，我才知道杨老师只有34岁，他比我猜测的年龄小多了，这也意味着他十年前做出的那篇经典论文还是24岁。和杨老师交流的过程中我们能感觉到他目前还在科研一线，MIR领域的前沿他都follow了，这一点真是太厉害了。</p><p>他说：“他不管有多忙，每周一都会空出来和他实验室的同学group meeting，读论文”。</p><p>我说：“杨老师，那你一定要坚持下去”我之所以这么说是因为目前很多中国大陆的青年学者，在找到教职，或者有行政职务以后就慢慢的不做科研了。这种现象无疑是非常不好的。</p><p>他说：“在他有了孩子以后确实没有以前那么多精力在科研上了，而且现在他和他太太想要第二个孩子。”</p><p>吃饭的时候我还问杨老师知道台大的李宏毅老师吗？他说知道啊，我说在大陆这边很多学生都听过他的深度学习课，他的课讲得非常好，很受学生欢迎。杨老师打趣说:”李宏毅老师是台湾AI界的网红，他实验室很多学生如果不懂深度学习他也会让他们去看李宏毅老师的课。”虽然我可能见不到李宏毅老师了，但是我希望杨老师如果有机会见到李宏毅老师，或许他会提起大陆有很多学生喜欢他讲的课吧。</p><p>吃完饭，李老师让高薇师姐和江师姐送杨老师去徐汇区那边的酒店，我主动提出说我也要去。我不能错过能和杨老师交流的机会。</p><p>在车上，师姐问起：“杨老师参加工作多久了，他说他参加工作已经八年半了，在他博士毕业之后他还去当了一年兵。”令人惊叹！</p><p>后来我们又问起台湾博士毕业需要什么条件</p><p>他说：”只要一篇IEEE transactions就行，但是硕博连读只用了三年半，我远超毕业的要求，我有3篇IEEE transactions“  </p><p>我们：“…”</p><p>杨老师还和我们交流我们的题目是怎么选的，我们说都是老师替我们选的，之后他聊起了他们实验室的学生，他说他招生很严格，招的学生都基本上是要去国外读PHD的，所以学生都很有motivation，他们都掌握了很多的乐理，有个学生本科是学电子工程的，但是选修很多做作曲的课，所以这对研究很有帮助。他们实验室现在有五个学生在做算法作曲。</p><p>他说：“他觉得他对学生很好，junior的学生刚进来会先跟着senior的学生做，senior的学生的题目他会帮助制定，但是也要他们有兴趣做才行”</p><p>后来我们聊起了group meeting和idea，师姐问杨老师会不会给学生想idea，他说他的idea经常一提出来就被学生否定，因为学生都能想到更好的idea，不过这样他都很开心。<strong>他还说在他们的group meeting前他会要求学生先提交要说的东西，如果他觉得他的学生报告的主题知识介绍自己所做的方向，他会建议他的学生换一个报告主题。因为他觉得group meeting不是学生汇报给老师听，要汇报可以单独汇报，而是要学生相互交流，讨论一些有意思的idea。他并不需要学生和他来讲，因为学生讲的对于杨老师来说不是第一次听，而是早就听了好几次了。</strong></p><p>听到这么一说，我和两位师姐面面相觑，因为我们的组会好像就当成向老师报告，而且很多听的同学并不会参与到别人的报告当中。博士师姐说她之前的组会都做得不好，其实大家有何尝不是呢？<strong>听了杨老师这些，我们确实应该rethink我们的组会，因为我们在组会当中没有扮演好自己的角色</strong>。后来的我们还继续讨论一些学术，我们当中无一不深深的折服于杨老师的对整个研究领域的学术观点。</p><p>这篇博客我不能够完整地记录所有重要的对话，可能每个人都会记住自己认为重要的内容吧。从这次简短的交流可以看出：杨奕轩老师是一位MIR领域学术造诣很高的青年研究者，他也是一位管理有方的实验室负责人，他也非常的谦逊，平和。我不觉得他是一位谷歌学术引用已经3000多次的学术研究者，和他的交流过程让我觉得他像是一位博士师兄一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/与杨奕轩老师的合影.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在2019年的一月七日，李老师在群里发了一条消息，杨奕轩老师会在一月十日途经上海，到时候会一起吃饭交流！我实在是没有想到能够这么快就见到杨老师，杨老师是台湾中央研究院的老师，他实验室的
      
    
    </summary>
    
      <category term="学术交流" scheme="http://yoursite.com/categories/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="学术交流" scheme="http://yoursite.com/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>2018年度回顾</title>
    <link href="http://yoursite.com/2018/12/30/2018%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2018/12/30/2018年度回顾/</id>
    <published>2018-12-30T11:17:15.000Z</published>
    <updated>2018-12-30T13:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>忙里偷闲，决定在一年的倒数第二天回顾下自己的2018年。</p><p>本着现代人不喜欢看太长的文字，太长的视频。我决定用自问自答的方式完成这篇年度总结。</p><p>Q代表我向自己提问，A代表我回答自己的提问。</p><ol><li><p>Q：2018年是你人生进程中相当重要的一年，有哪些新的变化和感受？</p><p>A：这一年里我结束了写满失望的本科生涯，离开了生活了22年的湖南，来到了一直想来的上海，到fdu继续自己的学生生涯。在后半年熬夜的天数暴增。同样在这一年我终于萌生出对计算机的喜爱，严格来说这一年开始写下第一行程序，想要学习一些新奇的计算机技术。离开了家乡才知道原来自己的普通话是多么的糟糕！这一年终于开始写博客，在未来会继续维护两个博客。</p></li><li><p>Q：2018年最有价值的一个选择？</p><p>A：很早就揣着要环游世界的想法，然而那只是一个想法，从来没有认真的实现它过。所以今年的最佳选择是2018年九月收到复旦大学登山协会一条关于穿越炉西峡的推送，我只用了几分钟考虑就决定参加。这是一个美好又意义深远开始，后来我还和华师大萤火虫去了温州雁荡山，寒假里我还要去宝岛台湾完成环岛活动。或许那一晚会是我完成环游世界梦想的开端。</p></li><li><p>Q：2018年最遗憾的一件事？</p><p>A：和一个认识多年的朋友闹掰了，近一年没有说过话了。我犯过的错误很多，这是其中一个。</p></li><li><p>Q：2018年看过的最佳电影？</p><p>A：从我全年线下和线上看过的四十多部各种题材的电影候选里。《爱在黎明破晓时》《爱在日落黄昏时》是我心中的最佳电影。电影里对爱情和性的谈论真是impressive，我觉得没有谈过恋爱的人恋爱必看，还没有结婚的结婚前必看，啊，已经结婚了？还是必看。</p></li><li><p>Q：2018年玩过的最佳游戏？</p><p>A：今年花了不少钱在购买游戏，游戏设备上。手上目前屯了(八方旅人，黑暗之魂)没玩，真正完整玩完了的游戏只有《塞尔达传说·旷野之息》，《返校》，《死亡细胞》，恕我实在是没有时间玩游戏。毫无疑问，《旷野之息》是我心中最佳游戏，在我做本科毕设的时候我花了大概85小时在旷野之息上。谁知道这是我时间最富裕的一段时间了，后来我就再也没有充足时间，能够全身心地去鉴赏一款游戏了。在我心中具有优秀设计的游戏就像艺术品一样。</p></li><li><p>Q：2018年看过的最佳书籍？</p><p>A：说来惭愧，这应该是我做得最不好的事情了。在阅读方面，读的书籍实在是太少太少了。如果愣是要少中选优的话是《创新公司皮克斯的启示》。理由是：它讲了一家公司为什么能成为一家创新公司，虽然我没有公司，不过我从里面学到如何和聪明人相处？今年在阅读方面我简直就是个loser，然而我在知乎上却读了6600万字，阅读的时间都去哪了？呵呵，花在知乎上了。真是少刷知乎多读书的反面典型。</p></li><li><p>Q：明白的最深刻的一个道理？</p><p>A：很多事情，我们只能看到表面，表面上看起来很酷，实际上真正做起来很难。就像人工智能看起来很酷，真正从事起来发现这是一堆数学，这个工作一点都不酷；就像我们玩到一个优秀游戏后，心里自然而然就有一种冲动，我为什么不能成为一个游戏设计者，然而当看到游戏开发背后的故事时，会发现游戏开发那一点都不酷，相当的无聊。</p></li><li><p>Q：新年有什么愿望？</p><p>A：希望父母身体健康，希望新的一年里自己的英语听说读写水平有好的进步。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忙里偷闲，决定在一年的倒数第二天回顾下自己的2018年。&lt;/p&gt;
&lt;p&gt;本着现代人不喜欢看太长的文字，太长的视频。我决定用自问自答的方式完成这篇年度总结。&lt;/p&gt;
&lt;p&gt;Q代表我向自己提问，A代表我回答自己的提问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Q：2018年是你人生进程
      
    
    </summary>
    
      <category term="只关心自己" scheme="http://yoursite.com/categories/%E5%8F%AA%E5%85%B3%E5%BF%83%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="年度总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>近窥MIREX-Like数据集和MIREX 08数据集</title>
    <link href="http://yoursite.com/2018/12/26/%E8%BF%91%E7%AA%A5MIREX-Like%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8CMIREX%2008%20%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/26/近窥MIREX-Like数据集和MIREX 08 数据集/</id>
    <published>2018-12-26T12:04:53.000Z</published>
    <updated>2019-01-12T14:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章翻译自<a href="https://musicinformationretrieval.wordpress.com/2017/03/16/take-a-closure-look-at-the-dataset/" target="_blank" rel="noopener">Student blog for the MIR course, Master in Sound and Music Computing, Universitat Pompeu Fabra (2017)</a>。我觉得还挺有意思的就翻译了一下，有些我拿不准的地方我就引用了原文的词语。这两个数据集还挺有意思。</p><hr><p>MIREX-Like数据集第一次在10th International Symposium on Computer Music Multidisciplinary Research-CMMR‘2013会议上公布出来[1]，由于一直缺乏标准的，标注质量好的音乐情感数据集，研究者们在绝大部分音乐情感学术研究里都使用自己制作的数据集，这导致他们取得的结果不能够在同一个数据集上进行比较。尽管每年MIREX 情感识别竞赛有mirex mood classification数据集，但是这个数据集不是公开的。新的MIREX-Like数据集 包含了903首音乐样本，同样这也是一个用于音乐情感研究的多模态数据集，它还囊括了歌词和每首歌的MIDI，但是它只有196首歌曲的MIDI。</p><ul><li><strong>数据集的获取</strong></li></ul><p>MIREX-Like数据集的制作者从ALLMusic收集数据，ALLMusic上的音乐标注都是由专业人员标注，而不是Last.FM的数据都是由音乐社区中的音乐听众标注的。所以ALLMusic的标注可能更加可靠。制作者收集标注时使用的情感标签和MIREX 08数据集是一致的。如果某首音乐的标签属于多个类别，那么他们会偏向选择标签数量更多的情感类别。比如：一首歌有’passionate‘(Cluster1)，‘confident’(Cluster1),’humorous‘(Cluster4)，那么这首歌会被分类到Cluster1。MIREX-Like数据集总共903首音乐歌曲，在五个类别上的数量分布是很平衡的，其中18.8%cluster 1, 18.2% cluster 2, 23.8% cluster 3, 21.2% cluster 4 and 18.1% cluster 5。</p><ul><li><strong>数据特征</strong></li></ul><p>即便标签都是由专业人员标注，这些标签在五个类别的的划分仍然不是很合理。尽管我们不能直接比较两个数据集，因为我们没有办法听到MIREX 08数据集的音乐文件。通过一个简单的验证步骤，我们能够得到结论：MIREX-Like数据集的歧义性(原文用的是ambiguity)比MIREX 08高。</p><p>的确，拿我们论文[2]当中用过的特征，使用SVM在MIREX-Like数据集分类，accuracy只有区区的40%，相比MIREX 08上的大多数结果在60%左右，这是一个很低的结果。MIREX-Like数据集的作者也在该文章[1]中使用了他们的分类方法，用SVM分类也只有44.9%的分类准确率。然而，他们使用一些旋律相关特征时，准确率可以提高到52.8%。他们基于旋律自动提取系统提取的98个旋律相关特征，尽管这些特征的用途并不相同。</p><ul><li><strong>类别分析</strong></li></ul><p>就在语义空间表示而言，用来讨论分析情感分类方法使用的不同情感分类类别是非常重要的，因为它或许能够解释这些分类算法的混乱。文献[4]分析了不同情感空间表示的intra-cluster similarity(类内相似性)和inter-cluster similarity(类间相似性)。intra-cluster similarity衡量的是<strong>community-based表征和expert-based表征(如Russell情感表示[5])之间的一致性</strong></p><p>就MIREX使用的五类情感类别而言，具有最低intra-cluster similarity的是cluster2(sweet, good natured,cheerful, rollicking, amiable, fun)，也许这么普通大众和专家意见如此一致的原因是这一类都是一些使人快乐的音乐。然而如果使用的形容词如果不是如此普通寻常的词语的话，这样做也许会降低这个值。总之MIREX 的情感表示的intra-cluster similarity相当高。</p><p>inter-cluster similarity，它在音乐情感分类方法中非常重要，衡量的是不同的情感类别之间的独立性(原文用的how separable the cluster are)，它的计算方法是取一个类别质心(类别内所有点的平均值)到其他所有类别质心之间的余弦距离，文献[4]给出了MIREX clusters类别的inter-cluster similarity混淆矩阵(confusion matrix)。这个矩阵告诉我们，cluster1和cluster5的值最低，表示这两个情感类别相当相似。</p><p>这些发现和MIREX竞赛上的结果是一致的，这两类的混淆性也很显著(见文献[6]），文献6也给出了cluster2和cluster4的混淆性(confusion)。</p><p>此外观察到的最独立的cluster5和cluster2，在MIREX 分类结果上也具有比较小的混淆性(confusion)[4]。</p><p><img src="https://github.com/1996Wanglei/1996wanglei.github.io/blob/master/images/Mirex-like%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E6%8F%92%E5%9B%BE.jpg" alt></p><p>Laurier表示MIREX的情感类别表示，还有在他研究里的其他情感表示既有优点但是也有局限性，观察到的不同MIREX cluster之间的混淆性和相似性验证了先前分析的结果。</p><p>从Lauriers分析中的计算结果来看，他认为MIREX的情感表示目前不是一个最优的表示方法。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] R. Panda, R. Malheiro, B. Rocha, A. Oliveira, and R. P. Paiva, “Multi-Modal Music Emotion Recognition: A New Dataset, Methodology and Comparative Analysis” 10th International Symposium on Computer Music Multidisciplinary Research – CMMR’2013.</p><p>[2] Laurier, Cyril, et al. “Audio music mood classification using support vector machine.” <em>MIREX task on Audio Mood Classification</em> (2007): 2-4.</p><p>[3] Salamon, Justin, Bruno Rocha, and Emilia Gómez. “Musical genre classification using melody features extracted from polyphonic music signals.” <em>Acoustics, Speech and Signal Processing (ICASSP), 2012 IEEE International Conference on</em>. IEEE, 2012.</p><p>[4] Laurier, Cyril. <em>Automatic classification of musical mood by content based analysis</em>. Universitat Pompeu Fabra, 2011.</p><p>[5] Ressel, J. A. “A circumplex model of affect.” <em>J. Personality and Social Psychology</em> 39 (1980): 1161-78.</p><p>[6] Downie, X. H. J. S., Cyril Laurier, and M. B. A. F. Ehmann. “The 2007 MIREX audio mood classification task: Lessons learned.” <em>Proc. 9th Int. Conf. Music Inf. Retrieval</em>. 2008.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://musicinformationretrieval.wordpress.com/2017/03/16/take-a-closure-look-at-the-dataset/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Dataset" scheme="http://yoursite.com/categories/Dataset/"/>
    
    
      <category term="Music Emotion Rearch" scheme="http://yoursite.com/tags/Music-Emotion-Rearch/"/>
    
      <category term="文章翻译" scheme="http://yoursite.com/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
